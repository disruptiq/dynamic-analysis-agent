"""
Binary Analysis Engine for Dynamic Analysis Agent

This module provides capabilities to analyze compiled binaries for vulnerabilities
without requiring source code access.
"""

import re
import os
import subprocess
import requests
from typing import List, Dict, Any, Optional, Tuple, Set
from urllib.parse import urljoin, urlparse
import tempfile
import hashlib

class BinaryAnalyzer:
    """Binary analysis engine for compiled applications"""

    def __init__(self, base_url: str):
        self.base_url = base_url
        self.vulnerabilities: List[Dict[str, Any]] = []
        self.analyzed_binaries: Set[str] = set()
        self.temp_dir = tempfile.mkdtemp()

    def analyze_application_binaries(self) -> List[Dict[str, Any]]:
        """
        Analyze application binaries for vulnerabilities

        Returns:
            List of discovered vulnerabilities
        """
        # Discover binary files
        binary_urls = self._discover_binary_files()

        for binary_url in binary_urls:
            self._analyze_binary(binary_url)

        # Clean up temp directory
        self._cleanup()

        return self.vulnerabilities

    def _discover_binary_files(self) -> List[str]:
        """Discover binary files in the application"""
        binary_urls = []

        try:
            response = make_request(self.base_url)
            if not response:
                return binary_urls

            content = response.text

            # Look for binary file extensions and download links
            binary_extensions = [
                '.exe', '.dll', '.so', '.dylib', '.bin', '.elf',
                '.jar', '.war', '.ear', '.class', '.pyc', '.pyd'
            ]

            # Find links to binary files
            link_pattern = r'href=["\']([^"\']+)["\']'
            links = re.findall(link_pattern, content, re.IGNORECASE)

            for link in links:
                if not link.startswith(('http://', 'https://', 'mailto:', 'javascript:')):
                    full_url = urljoin(self.base_url, link)

                    # Check if it looks like a binary file
                    if any(link.lower().endswith(ext) for ext in binary_extensions):
                        binary_urls.append(full_url)

                    # Also check common binary paths
                    binary_paths = [
                        '/static/', '/assets/', '/bin/', '/lib/',
                        '/download/', '/files/', '/uploads/'
                    ]

                    if any(binary_path in link for binary_path in binary_paths):
                        # Download and check file signature
                        if self._is_binary_file(full_url):
                            binary_urls.append(full_url)

        except Exception:
            pass

        return binary_urls[:10]  # Limit to avoid excessive analysis

    def _is_binary_file(self, url: str) -> bool:
        """Check if a URL points to a binary file by examining headers/content"""
        try:
            response = requests.head(url, timeout=10, allow_redirects=True)
            if response.status_code != 200:
                return False

            content_type = response.headers.get('content-type', '').lower()

            # Check content type for binary files
            binary_types = [
                'application/octet-stream',
                'application/x-executable',
                'application/x-sharedlib',
                'application/java-archive',
                'application/x-msdownload'
            ]

            if any(binary_type in content_type for binary_type in binary_types):
                return True

            # Check file extension
            path = urlparse(url).path.lower()
            binary_extensions = ['.exe', '.dll', '.so', '.bin', '.jar', '.class']
            if any(path.endswith(ext) for ext in binary_extensions):
                return True

        except Exception:
            pass

        return False

    def _analyze_binary(self, binary_url: str):
        """Analyze a single binary file"""
        if binary_url in self.analyzed_binaries:
            return

        self.analyzed_binaries.add(binary_url)

        try:
            # Download the binary
            local_path = self._download_binary(binary_url)
            if not local_path:
                return

            # Perform various binary analysis techniques
            self._analyze_file_headers(local_path, binary_url)
            self._analyze_strings(local_path, binary_url)
            self._check_vulnerabilities(local_path, binary_url)
            self._analyze_dependencies(local_path, binary_url)

        except Exception as e:
            pass

    def _download_binary(self, url: str) -> Optional[str]:
        """Download a binary file to temporary location"""
        try:
            response = requests.get(url, timeout=30, stream=True)
            if response.status_code != 200:
                return None

            # Generate filename from URL
            filename = os.path.basename(urlparse(url).path)
            if not filename:
                # Use hash of URL as filename
                filename = hashlib.md5(url.encode()).hexdigest()

            local_path = os.path.join(self.temp_dir, filename)

            with open(local_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)

            return local_path

        except Exception:
            return None

    def _analyze_file_headers(self, file_path: str, original_url: str):
        """Analyze binary file headers for basic information"""
        try:
            with open(file_path, 'rb') as f:
                header = f.read(64)  # Read first 64 bytes

            # Check for common file signatures
            signatures = {
                b'\x7fELF': 'ELF executable',
                b'MZ': 'Windows executable',
                b'PK\x03\x04': 'ZIP/JAR archive',
                b'\xca\xfe\xba\xbe': 'Java class file',
            }

            for signature, file_type in signatures.items():
                if header.startswith(signature):
                    # Check file size
                    file_size = os.path.getsize(file_path)
                    if file_size > 100 * 1024 * 1024:  # 100MB
                        self._report_vulnerability({
                            'type': 'large_binary_file',
                            'severity': 'INFO',
                            'description': f'Large {file_type} file detected ({file_size} bytes)',
                            'evidence': f'URL: {original_url}',
                            'recommendation': 'Consider file size limits and compression'
                        })

                    # Check for executable permissions
                    if file_type in ['ELF executable', 'Windows executable']:
                        file_mode = os.stat(file_path).st_mode
                        if file_mode & 0o111:  # Executable bit set
                            self._report_vulnerability({
                                'type': 'executable_file_exposed',
                                'severity': 'MEDIUM',
                                'description': f'Executable {file_type} file exposed via web',
                                'evidence': f'URL: {original_url}',
                                'recommendation': 'Avoid exposing executable files directly via web'
                            })

                    break

        except Exception:
            pass

    def _analyze_strings(self, file_path: str, original_url: str):
        """Extract and analyze strings from binary files"""
        try:
            # Use strings command if available
            result = subprocess.run(['strings', file_path],
                                  capture_output=True, text=True, timeout=30)

            if result.returncode == 0:
                strings_output = result.stdout
                self._analyze_string_patterns(strings_output, original_url)

        except (subprocess.TimeoutExpired, FileNotFoundError):
            # Fallback: simple string extraction
            try:
                with open(file_path, 'rb') as f:
                    data = f.read()

                # Extract printable strings
                strings_output = ''
                current_string = ''

                for byte in data:
                    if 32 <= byte <= 126:  # Printable ASCII
                        current_string += chr(byte)
                    else:
                        if len(current_string) >= 4:  # Minimum string length
                            strings_output += current_string + '\n'
                        current_string = ''

                self._analyze_string_patterns(strings_output, original_url)

            except Exception:
                pass

    def _analyze_string_patterns(self, strings_output: str, original_url: str):
        """Analyze extracted strings for security issues"""
        lines = strings_output.split('\n')

        # Look for sensitive patterns
        sensitive_patterns = [
            (r'password', 'HARD_CODED_PASSWORD', 'HIGH', 'Hard-coded password detected'),
            (r'api[_-]?key', 'HARD_CODED_API_KEY', 'HIGH', 'Hard-coded API key detected'),
            (r'secret', 'HARD_CODED_SECRET', 'HIGH', 'Hard-coded secret detected'),
            (r'token', 'HARD_CODED_TOKEN', 'MEDIUM', 'Hard-coded token detected'),
            (r'admin', 'HARD_CODED_ADMIN', 'MEDIUM', 'Hard-coded admin credentials detected'),
            (r'debug', 'DEBUG_ENABLED', 'LOW', 'Debug information exposed'),
            (r'/tmp/', 'TEMP_FILE_USAGE', 'LOW', 'Temporary file usage detected'),
            (r'system\s*\(', 'SYSTEM_CALL', 'MEDIUM', 'System command execution detected'),
            (r'eval\s*\(', 'CODE_EVALUATION', 'HIGH', 'Code evaluation detected'),
        ]

        found_issues = set()

        for line in lines:
            line_lower = line.lower().strip()
            if not line_lower:
                continue

            for pattern, issue_type, severity, description in sensitive_patterns:
                if re.search(pattern, line_lower, re.IGNORECASE):
                    issue_key = f"{issue_type}_{hash(line) % 1000}"  # Avoid duplicates
                    if issue_key not in found_issues:
                        found_issues.add(issue_key)
                        self._report_vulnerability({
                            'type': issue_type.lower(),
                            'severity': severity,
                            'description': description,
                            'evidence': f'String: {line[:100]}... (URL: {original_url})',
                            'recommendation': 'Remove hard-coded sensitive information from binaries'
                        })

                        # Limit findings per file
                        if len(found_issues) >= 10:
                            break

            if len(found_issues) >= 10:
                break

    def _check_vulnerabilities(self, file_path: str, original_url: str):
        """Check for known vulnerabilities in binary files"""
        try:
            # Get file hash for vulnerability database lookup
            file_hash = self._calculate_file_hash(file_path)

            # Check against known vulnerable hashes (simplified example)
            vulnerable_hashes = {
                # Example vulnerable file hashes (in practice, this would be a database)
            }

            if file_hash in vulnerable_hashes:
                vuln_info = vulnerable_hashes[file_hash]
                self._report_vulnerability({
                    'type': 'known_vulnerable_binary',
                    'severity': 'CRITICAL',
                    'description': f'Known vulnerable binary: {vuln_info.get("name", "Unknown")}',
                    'evidence': f'File hash: {file_hash} (URL: {original_url})',
                    'recommendation': 'Update to latest version or apply security patch'
                })

        except Exception:
            pass

    def _analyze_dependencies(self, file_path: str, original_url: str):
        """Analyze binary dependencies for security issues"""
        try:
            # Try to extract dependencies using various tools
            if self._is_elf_file(file_path):
                self._analyze_elf_dependencies(file_path, original_url)
            elif self._is_pe_file(file_path):
                self._analyze_pe_dependencies(file_path, original_url)
            elif self._is_jar_file(file_path):
                self._analyze_jar_dependencies(file_path, original_url)

        except Exception:
            pass

    def _is_elf_file(self, file_path: str) -> bool:
        """Check if file is ELF format"""
        try:
            with open(file_path, 'rb') as f:
                return f.read(4) == b'\x7fELF'
        except Exception:
            return False

    def _is_pe_file(self, file_path: str) -> bool:
        """Check if file is PE format"""
        try:
            with open(file_path, 'rb') as f:
                return f.read(2) == b'MZ'
        except Exception:
            return False

    def _is_jar_file(self, file_path: str) -> bool:
        """Check if file is JAR format"""
        try:
            with open(file_path, 'rb') as f:
                return f.read(4) == b'PK\x03\x04'
        except Exception:
            return False

    def _analyze_elf_dependencies(self, file_path: str, original_url: str):
        """Analyze ELF file dependencies"""
        try:
            # Use ldd to check dynamic dependencies
            result = subprocess.run(['ldd', file_path],
                                  capture_output=True, text=True, timeout=10)

            if result.returncode == 0:
                dependencies = result.stdout

                # Check for potentially vulnerable library versions
                vulnerable_libs = [
                    ('glibc', r'libc\.so\.6'),
                    ('openssl', r'libssl\.so'),
                    ('zlib', r'libz\.so'),
                ]

                for lib_name, pattern in vulnerable_libs:
                    if re.search(pattern, dependencies, re.IGNORECASE):
                        # In a real implementation, you would check version numbers
                        # For now, just flag the presence
                        pass

        except (subprocess.TimeoutExpired, FileNotFoundError):
            pass

    def _analyze_pe_dependencies(self, file_path: str, original_url: str):
        """Analyze PE file dependencies"""
        # This would require tools like Dependency Walker or similar
        # For now, we'll skip detailed PE analysis
        pass

    def _analyze_jar_dependencies(self, file_path: str, original_url: str):
        """Analyze JAR file dependencies"""
        try:
            # Extract MANIFEST.MF to check dependencies
            result = subprocess.run(['unzip', '-p', file_path, 'META-INF/MANIFEST.MF'],
                                  capture_output=True, text=True, timeout=10)

            if result.returncode == 0:
                manifest = result.stdout

                # Check for vulnerable library versions in manifest
                # This is a simplified check
                if 'spring-boot' in manifest.lower():
                    self._report_vulnerability({
                        'type': 'outdated_framework',
                        'severity': 'MEDIUM',
                        'description': 'Spring Boot framework detected - check for known vulnerabilities',
                        'evidence': f'JAR manifest (URL: {original_url})',
                        'recommendation': 'Keep framework libraries updated'
                    })

        except (subprocess.TimeoutExpired, FileNotFoundError):
            pass

    def _calculate_file_hash(self, file_path: str) -> str:
        """Calculate SHA256 hash of file"""
        try:
            hash_sha256 = hashlib.sha256()
            with open(file_path, 'rb') as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hash_sha256.update(chunk)
            return hash_sha256.hexdigest()
        except Exception:
            return ""

    def _report_vulnerability(self, vuln: Dict[str, Any]):
        """Report a discovered vulnerability"""
        # Avoid duplicates
        for existing_vuln in self.vulnerabilities:
            if (existing_vuln.get('type') == vuln.get('type') and
                existing_vuln.get('evidence') == vuln.get('evidence')):
                return

        self.vulnerabilities.append(vuln)

    def _cleanup(self):
        """Clean up temporary files"""
        try:
            import shutil
            shutil.rmtree(self.temp_dir, ignore_errors=True)
        except Exception:
            pass


def test_binary_analysis(base_url: str) -> List[Dict[str, Any]]:
    """
    Test for vulnerabilities using binary analysis

    Args:
        base_url: Base URL to test

    Returns:
        List of discovered vulnerabilities
    """
    analyzer = BinaryAnalyzer(base_url)
    return analyzer.analyze_application_binaries()
