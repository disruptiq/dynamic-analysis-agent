"""
Control Flow Analysis Engine for Dynamic Analysis Agent

This module analyzes application control flow to identify logic flaws,
authorization bypasses, and other control flow related vulnerabilities.
"""

import re
import requests
from typing import List, Dict, Any, Set, Optional, Tuple
from urllib.parse import urljoin, urlparse, parse_qs
# Using requests directly for HTTP operations

class ControlFlowNode:
    """Represents a node in the control flow graph"""

    def __init__(self, node_type: str, location: str, condition: Optional[str] = None):
        self.node_type = node_type  # 'entry', 'decision', 'action', 'exit'
        self.location = location  # URL, function, or code location
        self.condition = condition  # For decision nodes
        self.transitions: List['ControlFlowTransition'] = []
        self.properties: Dict[str, Any] = {}

class ControlFlowTransition:
    """Represents a transition between control flow nodes"""

    def __init__(self, source: ControlFlowNode, target: ControlFlowNode,
                 condition: Optional[str] = None, label: str = ''):
        self.source = source
        self.target = target
        self.condition = condition  # Condition for taking this transition
        self.label = label  # Human-readable label

class ControlFlowGraph:
    """Graph representing application control flow"""

    def __init__(self):
        self.nodes: List[ControlFlowNode] = []
        self.entry_points: List[ControlFlowNode] = []
        self.exit_points: List[ControlFlowNode] = []

    def add_node(self, node: ControlFlowNode) -> ControlFlowNode:
        """Add a node to the graph"""
        self.nodes.append(node)
        if node.node_type == 'entry':
            self.entry_points.append(node)
        elif node.node_type == 'exit':
            self.exit_points.append(node)
        return node

    def add_transition(self, transition: ControlFlowTransition):
        """Add a transition between nodes"""
        transition.source.transitions.append(transition)

    def find_paths(self, start_node: ControlFlowNode, end_node: ControlFlowNode,
                   max_depth: int = 20) -> List[List[ControlFlowNode]]:
        """Find all paths from start to end node"""
        paths = []
        visited = set()

        def dfs(current: ControlFlowNode, path: List[ControlFlowNode], depth: int):
            if depth > max_depth:
                return

            path.append(current)
            visited.add(current)

            if current == end_node:
                paths.append(path.copy())
            else:
                for transition in current.transitions:
                    if transition.target not in visited:
                        dfs(transition.target, path, depth + 1)

            path.pop()
            visited.remove(current)

        dfs(start_node, [], 0)
        return paths

class ControlFlowAnalyzer:
    """Control flow analysis engine"""

    def __init__(self, base_url: str):
        self.base_url = base_url
        self.graph = ControlFlowGraph()
        self.vulnerabilities: List[Dict[str, Any]] = []
        self.analyzed_urls: Set[str] = set()
        self.auth_patterns: Dict[str, List[str]] = {
            'login': ['login', 'signin', 'auth', 'authenticate'],
            'admin': ['admin', 'administrator', 'manage', 'control'],
            'user': ['user', 'profile', 'account', 'settings'],
        }

    def analyze_application(self) -> List[Dict[str, Any]]:
        """
        Perform comprehensive control flow analysis

        Returns:
            List of discovered vulnerabilities
        """
        # Build control flow graph by analyzing application structure
        self._build_control_flow_graph()

        # Analyze the graph for vulnerabilities
        self._analyze_authorization_bypass()
        self._analyze_business_logic_flaws()
        self._analyze_access_control_issues()
        self._analyze_session_management()

        return self.vulnerabilities

    def _build_control_flow_graph(self):
        """Build the control flow graph by analyzing the application"""
        # Start with main entry point
        main_entry = ControlFlowNode('entry', self.base_url, 'main_page')
        self.graph.add_node(main_entry)

        # Discover and analyze different application paths
        self._analyze_web_pages(main_entry)
        self._analyze_api_endpoints(main_entry)
        self._analyze_form_flows(main_entry)

    def _analyze_web_pages(self, entry_node: ControlFlowNode):
        """Analyze web pages for control flow patterns"""
        pages_to_analyze = [self.base_url]
        analyzed_pages = set()

        while pages_to_analyze:
            current_url = pages_to_analyze.pop(0)
            if current_url in analyzed_pages:
                continue

            analyzed_pages.add(current_url)

            try:
                response = requests.get(current_url, timeout=10)
                if response.status_code != 200:
                    continue

                content = response.text

                # Create node for this page
                page_node = ControlFlowNode('action', current_url, f'page_load_{urlparse(current_url).path}')
                self.graph.add_node(page_node)

                # Add transition from entry or previous page
                transition = ControlFlowTransition(entry_node, page_node, None, 'page_access')
                self.graph.add_transition(transition)

                # Analyze page content for control flow elements
                self._analyze_page_control_flow(content, page_node, pages_to_analyze)

            except Exception:
                continue

    def _analyze_page_control_flow(self, content: str, page_node: ControlFlowNode,
                                  pages_to_analyze: List[str]):
        """Analyze a page's content for control flow elements"""

        # Look for conditional content (login/logout states)
        conditional_patterns = [
            (r'if\s*\(\s*[^}]*(?:login|auth|user)[^}]*\)', 'authentication_check'),
            (r'<\w+[^>]*class=["\'][^"\']*(?:login|logout|auth)[^"\']*["\']', 'auth_ui_element'),
            (r'(?:admin|manager|control)\s+panel', 'admin_access'),
        ]

        for pattern, condition_type in conditional_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                decision_node = ControlFlowNode('decision', f'{page_node.location}_{condition_type}',
                                              condition_type)
                self.graph.add_node(decision_node)

                # Add transitions for true/false branches
                true_transition = ControlFlowTransition(page_node, decision_node, 'authenticated',
                                                      'auth_success')
                false_transition = ControlFlowTransition(page_node, decision_node, 'not_authenticated',
                                                       'auth_failure')

                self.graph.add_transition(true_transition)
                self.graph.add_transition(false_transition)

        # Look for navigation links that create new paths
        link_pattern = r'href=["\']([^"\']+)["\']'
        links = re.findall(link_pattern, content, re.IGNORECASE)

        for link in links[:10]:  # Limit to avoid excessive analysis
            if not link.startswith(('http://', 'https://', 'mailto:', 'javascript:', '#')):
                full_url = urljoin(self.base_url, link)
                if urlparse(full_url).netloc == urlparse(self.base_url).netloc:
                    pages_to_analyze.append(full_url)

                    # Create transition to new page
                    link_node = ControlFlowNode('action', full_url, f'navigate_to_{link}')
                    self.graph.add_node(link_node)

                    transition = ControlFlowTransition(page_node, link_node, None, f'link_click_{link}')
                    self.graph.add_transition(transition)

    def _analyze_api_endpoints(self, entry_node: ControlFlowNode):
        """Analyze API endpoints for control flow"""
        # Common API patterns to test
        api_endpoints = [
            '/api/', '/rest/', '/graphql', '/v1/', '/v2/',
            '/admin/', '/user/', '/auth/', '/login', '/logout'
        ]

        for endpoint in api_endpoints:
            api_url = urljoin(self.base_url, endpoint)
            api_node = ControlFlowNode('action', api_url, f'api_call_{endpoint}')
            self.graph.add_node(api_node)

            transition = ControlFlowTransition(entry_node, api_node, None, f'api_access_{endpoint}')
            self.graph.add_transition(transition)

    def _analyze_form_flows(self, entry_node: ControlFlowNode):
        """Analyze form submission flows"""
        try:
            response = requests.get(self.base_url, timeout=10)
            if response.status_code != 200:
                return

            content = response.text

            # Find forms
            form_pattern = r'<form[^>]*action=["\']([^"\']*)["\'][^>]*method=["\']([^"\']*)["\'][^>]*>(.*?)</form>'
            forms = re.findall(form_pattern, content, re.DOTALL | re.IGNORECASE)

            for action, method, form_content in forms:
                form_node = ControlFlowNode('action', urljoin(self.base_url, action),
                                          f'form_submit_{method}')
                self.graph.add_node(form_node)

                # Check form action for authentication requirements
                auth_required = self._check_authentication_requirement(action, form_content)

                condition = 'authenticated' if auth_required else None
                transition = ControlFlowTransition(entry_node, form_node, condition,
                                                 f'form_submit_{method}')
                self.graph.add_transition(transition)

                # Analyze form fields for potential bypasses
                self._analyze_form_fields(form_content, form_node)

        except Exception:
            pass

    def _check_authentication_requirement(self, action: str, form_content: str) -> bool:
        """Check if a form action requires authentication"""
        auth_indicators = [
            'login', 'signin', 'auth', 'authenticate', 'password',
            'username', 'email', 'token', 'session'
        ]

        action_lower = action.lower()
        content_lower = form_content.lower()

        return any(indicator in action_lower or indicator in content_lower
                  for indicator in auth_indicators)

    def _analyze_form_fields(self, form_content: str, form_node: ControlFlowNode):
        """Analyze form fields for potential control flow issues"""
        field_pattern = r'<input[^>]*name=["\']([^"\']+)["\'][^>]*type=["\']([^"\']*)["\']'
        fields = re.findall(field_pattern, form_content, re.IGNORECASE)

        for field_name, field_type in fields:
            # Check for hidden fields that might be tampered with
            if field_type.lower() == 'hidden':
                hidden_node = ControlFlowNode('decision', f'{form_node.location}_hidden_{field_name}',
                                            f'hidden_field_{field_name}')
                self.graph.add_node(hidden_node)

                # Transitions for legitimate vs tampered values
                legitimate = ControlFlowTransition(form_node, hidden_node, 'legitimate_value',
                                                 'valid_hidden_field')
                tampered = ControlFlowTransition(form_node, hidden_node, 'tampered_value',
                                               'modified_hidden_field')

                self.graph.add_transition(legitimate)
                self.graph.add_transition(tampered)

                # Check if hidden field contains sensitive data
                if any(sensitive in field_name.lower() for sensitive in
                       ['role', 'admin', 'level', 'permission', 'user_id']):
                    self._report_vulnerability({
                        'type': 'hidden_field_manipulation',
                        'severity': 'MEDIUM',
                        'description': f'Hidden field {field_name} may contain sensitive authorization data',
                        'evidence': f'Hidden input: {field_name}',
                        'recommendation': 'Avoid storing authorization data in hidden form fields'
                    })

    def _analyze_authorization_bypass(self):
        """Analyze the control flow graph for authorization bypass vulnerabilities"""
        # Look for paths that bypass authentication checks
        for entry_point in self.graph.entry_points:
            for node in self.graph.nodes:
                if 'admin' in node.location.lower() or 'manage' in node.location.lower():
                    paths = self.graph.find_paths(entry_point, node)

                    for path in paths:
                        # Check if path goes through authentication
                        has_auth_check = any('auth' in n.location.lower() or 'login' in n.location.lower()
                                           for n in path)

                        if not has_auth_check:
                            self._report_vulnerability({
                                'type': 'authorization_bypass',
                                'severity': 'HIGH',
                                'description': 'Administrative function accessible without authentication',
                                'evidence': f'Path: {" -> ".join([n.location for n in path])}',
                                'recommendation': 'Implement proper authentication checks for admin functions'
                            })

    def _analyze_business_logic_flaws(self):
        """Analyze for business logic flaws in control flow"""
        # Look for unusual transitions or missing validations
        for node in self.graph.nodes:
            if node.node_type == 'decision':
                transitions = node.transitions

                # Check for decisions with only one outcome (potential bypass)
                if len(transitions) == 1:
                    self._report_vulnerability({
                        'type': 'business_logic_flaw',
                        'severity': 'MEDIUM',
                        'description': f'Decision point {node.condition} has only one possible outcome',
                        'evidence': f'Decision node: {node.location}',
                        'recommendation': 'Ensure all decision branches are properly implemented'
                    })

                # Check for transitions that skip important validations
                for transition in transitions:
                    if transition.condition and 'skip' in transition.condition.lower():
                        self._report_vulnerability({
                            'type': 'validation_bypass',
                            'severity': 'HIGH',
                            'description': 'Control flow allows skipping validation steps',
                            'evidence': f'Transition: {transition.label}',
                            'recommendation': 'Ensure all validation steps are mandatory'
                        })

    def _analyze_access_control_issues(self):
        """Analyze for access control issues"""
        # Test for IDOR patterns
        idor_patterns = [
            r'/user/(\d+)',
            r'/account/(\d+)',
            r'/profile/(\d+)',
            r'/admin/user/(\d+)',
        ]

        for pattern in idor_patterns:
            # Test with different user IDs
            for user_id in ['1', '2', '999']:
                test_url = re.sub(r'\(\d+\)', user_id, self.base_url + pattern.replace('(\\d+)', user_id))

                try:
                    response1 = requests.get(test_url, timeout=10)
                    response2 = requests.get(test_url.replace(user_id, '1'), timeout=10)

                    if response1.status_code == 200 and response2.status_code == 200:
                        # Both requests succeeded - potential IDOR
                        if response1.text != response2.text:  # Different content for different IDs
                            self._report_vulnerability({
                                'type': 'idor',
                                'severity': 'HIGH',
                                'description': 'Potential Insecure Direct Object Reference (IDOR) vulnerability',
                                'evidence': f'URL pattern: {pattern}',
                                'recommendation': 'Implement proper access control checks for object references'
                            })
                            break
                except Exception:
                    continue

    def _analyze_session_management(self):
        """Analyze session management in control flow"""
        # Look for session-related patterns
        session_patterns = [
            'session', 'cookie', 'token', 'jwt', 'auth',
            'login', 'logout', 'remember'
        ]

        session_nodes = [node for node in self.graph.nodes
                        if any(pattern in node.location.lower() for pattern in session_patterns)]

        if not session_nodes:
            self._report_vulnerability({
                'type': 'missing_session_management',
                'severity': 'MEDIUM',
                'description': 'No apparent session management detected',
                'evidence': 'Control flow analysis',
                'recommendation': 'Implement proper session management and timeout handling'
            })

        # Check for logout functionality
        has_logout = any('logout' in node.location.lower() for node in session_nodes)
        if not has_logout:
            self._report_vulnerability({
                'type': 'missing_logout',
                'severity': 'LOW',
                'description': 'No logout functionality detected',
                'evidence': 'Control flow analysis',
                'recommendation': 'Implement proper logout functionality'
            })

    def _report_vulnerability(self, vuln: Dict[str, Any]):
        """Report a discovered vulnerability"""
        # Avoid duplicates
        for existing_vuln in self.vulnerabilities:
            if (existing_vuln.get('type') == vuln.get('type') and
                existing_vuln.get('evidence') == vuln.get('evidence')):
                return

        self.vulnerabilities.append(vuln)

    def test_authorization_bypass(self) -> List[Dict[str, Any]]:
        """Test for authorization bypass vulnerabilities"""
        vulnerabilities = []

        # Test common bypass techniques
        bypass_tests = [
            ('url_manipulation', f"{self.base_url}/admin", f"{self.base_url}/admin/"),
            ('parameter_pollution', f"{self.base_url}/user?id=1", f"{self.base_url}/user?id=1&id=2"),
            ('method_manipulation', f"{self.base_url}/admin", 'POST'),  # Try POST instead of GET
        ]

        for test_name, url, variation in bypass_tests:
            try:
                # Test original request
                response1 = requests.get(url, timeout=10)

                # Test variation
                if isinstance(variation, str) and variation.startswith('http'):
                    response2 = requests.get(variation, timeout=10)
                else:
                    response2 = requests.request(variation, url, timeout=10)

                if (response1.status_code != response2.status_code and
                    response2.status_code == 200):
                    vulnerabilities.append({
                        'type': 'authorization_bypass',
                        'severity': 'HIGH',
                        'description': f'Potential authorization bypass via {test_name}',
                        'evidence': f'Original: {url} ({response1.status_code}) -> Variation: {variation} ({response2.status_code})',
                        'recommendation': 'Implement consistent authorization checks'
                    })

            except Exception:
                continue

        return vulnerabilities


def test_control_flow_analysis(base_url: str) -> List[Dict[str, Any]]:
    """
    Test for vulnerabilities using control flow analysis

    Args:
        base_url: Base URL to test

    Returns:
        List of discovered vulnerabilities
    """
    analyzer = ControlFlowAnalyzer(base_url)

    # Perform comprehensive control flow analysis
    vulnerabilities = analyzer.analyze_application()

    # Additional authorization bypass testing
    bypass_vulns = analyzer.test_authorization_bypass()
    vulnerabilities.extend(bypass_vulns)

    return vulnerabilities
