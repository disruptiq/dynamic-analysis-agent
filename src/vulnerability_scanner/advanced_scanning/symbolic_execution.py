"""
Symbolic Execution Engine for Dynamic Analysis Agent

This module implements symbolic execution techniques to explore all possible
code paths and find edge case vulnerabilities by analyzing program behavior
with symbolic inputs rather than concrete values.
"""

import re
import ast
import requests
from typing import List, Dict, Any, Optional, Set
from urllib.parse import urljoin, urlparse
# Using requests directly for HTTP operations

class SymbolicValue:
    """Represents a symbolic value in symbolic execution"""

    def __init__(self, name: str, constraints: List[str] = None):
        self.name = name
        self.constraints = constraints or []
        self.value_range = None
        self.possible_values = set()

    def add_constraint(self, constraint: str):
        """Add a constraint to this symbolic value"""
        self.constraints.append(constraint)

    def __str__(self):
        return f"Symbol({self.name})"

class SymbolicState:
    """Represents the symbolic state during execution"""

    def __init__(self):
        self.variables: Dict[str, SymbolicValue] = {}
        self.path_constraints: List[str] = []
        self.execution_path: List[str] = []

    def add_variable(self, name: str, symbolic_value: SymbolicValue):
        """Add a symbolic variable to the state"""
        self.variables[name] = symbolic_value

    def add_constraint(self, constraint: str):
        """Add a path constraint"""
        self.path_constraints.append(constraint)

    def branch(self, condition: str) -> 'SymbolicState':
        """Create a new state for branching"""
        new_state = SymbolicState()
        new_state.variables = self.variables.copy()
        new_state.path_constraints = self.path_constraints.copy()
        new_state.execution_path = self.execution_path.copy()
        new_state.add_constraint(condition)
        return new_state

class SymbolicExecutor:
    """Symbolic execution engine for web applications"""

    def __init__(self, base_url: str):
        self.base_url = base_url
        self.states: List[SymbolicState] = []
        self.vulnerabilities: List[Dict[str, Any]] = []
        self.explored_paths: Set[str] = set()

    def initialize_state(self) -> SymbolicState:
        """Initialize the symbolic execution state"""
        state = SymbolicState()

        # Create symbolic inputs commonly found in web applications
        symbolic_inputs = [
            ('user_input', 'string'),
            ('password', 'string'),
            ('email', 'email'),
            ('id', 'integer'),
            ('query', 'string'),
            ('search', 'string'),
            ('filename', 'string'),
            ('path', 'path')
        ]

        for name, input_type in symbolic_inputs:
            symbolic_value = SymbolicValue(f"sym_{name}")
            if input_type == 'integer':
                symbolic_value.constraints.append(f"{name}.isdigit()")
                symbolic_value.value_range = (0, 10000)
            elif input_type == 'email':
                symbolic_value.constraints.append(f"{name}.count('@') == 1")
                symbolic_value.constraints.append(f"'.' in {name}")
            elif input_type == 'path':
                symbolic_value.constraints.append(f"not {name}.startswith('..')")
                symbolic_value.constraints.append(f"not '..' in {name}")

            state.add_variable(name, symbolic_value)

        return state

    def analyze_javascript(self, js_code: str, state: SymbolicState) -> List[SymbolicState]:
        """Analyze JavaScript code symbolically"""
        new_states = [state]

        # Extract potential vulnerability patterns
        patterns = [
            (r'(\w+)\s*=\s*document\.getElementById\(["\']([^"\']+)["\']', 'dom_access'),
            (r'eval\s*\(\s*([^)]+)', 'code_execution'),
            (r'innerHTML\s*=\s*([^;]+)', 'html_injection'),
            (r'document\.write\s*\(\s*([^)]+)', 'html_injection'),
            (r'location\.href\s*=\s*([^;]+)', 'open_redirect'),
            (r'window\.open\s*\(\s*([^)]+)', 'popup_injection'),
        ]

        for pattern, vuln_type in patterns:
            matches = re.finditer(pattern, js_code, re.IGNORECASE)
            for match in matches:
                variable = match.group(1)
                if variable in state.variables:
                    symbolic_var = state.variables[variable]

                    if vuln_type == 'code_execution':
                        self._check_code_execution_vulnerability(symbolic_var, match.group(0))
                    elif vuln_type == 'html_injection':
                        self._check_html_injection_vulnerability(symbolic_var, match.group(0))
                    elif vuln_type == 'open_redirect':
                        self._check_open_redirect_vulnerability(symbolic_var, match.group(0))

        return new_states

    def analyze_php_code(self, php_code: str, state: SymbolicState) -> List[SymbolicState]:
        """Analyze PHP code symbolically"""
        new_states = [state]

        # Extract potential vulnerability patterns in PHP
        patterns = [
            (r'\$_(GET|POST|REQUEST|COOKIE)\s*\[\s*["\']([^"\']+)["\']', 'user_input'),
            (r'eval\s*\(\s*([^)]+)', 'code_execution'),
            (r'include\s*\(\s*([^)]+)', 'file_inclusion'),
            (r'require\s*\(\s*([^)]+)', 'file_inclusion'),
            (r'mysql_query\s*\(\s*([^)]+)', 'sql_injection'),
            (r'header\s*\(\s*["\']Location:\s*([^"\']+)', 'open_redirect'),
        ]

        for pattern, vuln_type in patterns:
            matches = re.finditer(pattern, php_code, re.IGNORECASE)
            for match in matches:
                variable_content = match.group(1) if vuln_type == 'user_input' else match.group(0)

                if vuln_type == 'user_input':
                    param_name = match.group(2)
                    if param_name not in state.variables:
                        symbolic_value = SymbolicValue(f"sym_{param_name}")
                        state.add_variable(param_name, symbolic_value)

                    symbolic_var = state.variables[param_name]
                    self._check_input_validation(symbolic_var, param_name)

                elif vuln_type == 'code_execution':
                    # Check if the eval content is controllable
                    self._check_code_execution_vulnerability_from_php(variable_content, match.group(0))

                elif vuln_type == 'file_inclusion':
                    self._check_file_inclusion_vulnerability(variable_content, match.group(0))

                elif vuln_type == 'sql_injection':
                    self._check_sql_injection_vulnerability(variable_content, match.group(0))

                elif vuln_type == 'open_redirect':
                    self._check_open_redirect_vulnerability_from_php(variable_content, match.group(0))

        return new_states

    def _check_input_validation(self, symbolic_var: SymbolicValue, param_name: str):
        """Check if user input is properly validated"""
        # Look for dangerous patterns in constraints
        dangerous_patterns = [
            r'\.\.',  # Directory traversal
            r'<script',  # XSS
            r'union.*select',  # SQL injection
            r';\s*rm\s+',  # Command injection
        ]

        for pattern in dangerous_patterns:
            if any(re.search(pattern, constraint, re.IGNORECASE) for constraint in symbolic_var.constraints):
                self.vulnerabilities.append({
                    'type': 'input_validation_bypass',
                    'severity': 'HIGH',
                    'parameter': param_name,
                    'description': f'Parameter {param_name} may allow dangerous input patterns',
                    'evidence': f'Pattern: {pattern}',
                    'recommendation': 'Implement proper input validation and sanitization'
                })

    def _check_code_execution_vulnerability(self, symbolic_var: SymbolicValue, code: str):
        """Check for code execution vulnerabilities"""
        if not any('sanitized' in constraint.lower() for constraint in symbolic_var.constraints):
            self.vulnerabilities.append({
                'type': 'code_execution',
                'severity': 'CRITICAL',
                'description': 'Potential code execution vulnerability',
                'evidence': code,
                'recommendation': 'Avoid using eval() with user-controlled input'
            })

    def _check_html_injection_vulnerability(self, symbolic_var: SymbolicValue, code: str):
        """Check for HTML injection vulnerabilities"""
        if not any('escaped' in constraint.lower() or 'sanitized' in constraint.lower()
                  for constraint in symbolic_var.constraints):
            self.vulnerabilities.append({
                'type': 'html_injection',
                'severity': 'HIGH',
                'description': 'Potential HTML injection vulnerability',
                'evidence': code,
                'recommendation': 'Use proper output encoding or sanitization'
            })

    def _check_open_redirect_vulnerability(self, symbolic_var: SymbolicValue, code: str):
        """Check for open redirect vulnerabilities"""
        if not any('validated' in constraint.lower() for constraint in symbolic_var.constraints):
            self.vulnerabilities.append({
                'type': 'open_redirect',
                'severity': 'MEDIUM',
                'description': 'Potential open redirect vulnerability',
                'evidence': code,
                'recommendation': 'Validate redirect URLs against whitelist'
            })

    def _check_code_execution_vulnerability_from_php(self, code: str, full_match: str):
        """Check for code execution in PHP context"""
        if re.search(r'\$_(GET|POST|REQUEST)', code):
            self.vulnerabilities.append({
                'type': 'remote_code_execution',
                'severity': 'CRITICAL',
                'description': 'Potential remote code execution via user input',
                'evidence': full_match,
                'recommendation': 'Never use eval() with user-controlled input'
            })

    def _check_file_inclusion_vulnerability(self, code: str, full_match: str):
        """Check for file inclusion vulnerabilities"""
        if re.search(r'\$_(GET|POST|REQUEST)', code):
            self.vulnerabilities.append({
                'type': 'file_inclusion',
                'severity': 'HIGH',
                'description': 'Potential file inclusion vulnerability',
                'evidence': full_match,
                'recommendation': 'Validate file paths and use whitelist approach'
            })

    def _check_sql_injection_vulnerability(self, code: str, full_match: str):
        """Check for SQL injection vulnerabilities"""
        if re.search(r'\$_(GET|POST|REQUEST)', code):
            self.vulnerabilities.append({
                'type': 'sql_injection',
                'severity': 'HIGH',
                'description': 'Potential SQL injection vulnerability',
                'evidence': full_match,
                'recommendation': 'Use prepared statements or proper escaping'
            })

    def _check_open_redirect_vulnerability_from_php(self, code: str, full_match: str):
        """Check for open redirect in PHP context"""
        if re.search(r'\$_(GET|POST|REQUEST)', code):
            self.vulnerabilities.append({
                'type': 'open_redirect',
                'severity': 'MEDIUM',
                'description': 'Potential open redirect vulnerability',
                'evidence': full_match,
                'recommendation': 'Validate redirect URLs against whitelist'
            })

    def analyze_webpage(self, url: str) -> List[Dict[str, Any]]:
        """
        Analyze a webpage using symbolic execution techniques

        Args:
            url: URL to analyze

        Returns:
            List of discovered vulnerabilities
        """
        try:
            response = requests.get(url, timeout=10)
            if response.status_code != 200:
                return []

            content = response.text

            # Initialize symbolic state
            initial_state = self.initialize_state()

            # Analyze JavaScript code
            js_pattern = r'<script[^>]*>(.*?)</script>'
            js_matches = re.findall(js_pattern, content, re.DOTALL | re.IGNORECASE)

            for js_code in js_matches:
                if js_code.strip():
                    self.analyze_javascript(js_code, initial_state)

            # Look for PHP code patterns (if exposed)
            php_patterns = [
                r'<\?php.*?\?>',
                r'<\?.*?\?>'
            ]

            for pattern in php_patterns:
                php_matches = re.findall(pattern, content, re.DOTALL | re.IGNORECASE)
                for php_code in php_matches:
                    self.analyze_php_code(php_code, initial_state)

            # Analyze forms for input validation issues
            self._analyze_forms(content, url)

            return self.vulnerabilities

        except Exception as e:
            return [{
                'type': 'analysis_error',
                'severity': 'INFO',
                'description': f'Symbolic execution analysis failed: {str(e)}',
                'evidence': str(e),
                'recommendation': 'Check application logs for detailed error information'
            }]

    def _analyze_forms(self, content: str, url: str):
        """Analyze HTML forms for input validation issues"""
        form_pattern = r'<form[^>]*>(.*?)</form>'
        input_pattern = r'<input[^>]*name=["\']([^"\']+)["\'][^>]*>'
        textarea_pattern = r'<textarea[^>]*name=["\']([^"\']+)["\'][^>]*>'

        forms = re.findall(form_pattern, content, re.DOTALL | re.IGNORECASE)

        for form in forms:
            inputs = re.findall(input_pattern, form, re.IGNORECASE)
            textareas = re.findall(textarea_pattern, form, re.IGNORECASE)

            all_inputs = inputs + textareas

            for input_name in all_inputs:
                # Check for common vulnerable input names
                vulnerable_patterns = [
                    ('id', r'^\d+$', 'Potential IDOR vulnerability'),
                    ('file', r'.*\.(php|asp|jsp|exe)$', 'Dangerous file extension allowed'),
                    ('path', r'\.\.', 'Directory traversal possible'),
                    ('url', r'^(?!https?://)', 'Relative URLs may allow open redirect'),
                ]

                for field_name, pattern, description in vulnerable_patterns:
                    if field_name.lower() in input_name.lower():
                        # This is a simplified check - in practice, you'd need to test actual validation
                        self.vulnerabilities.append({
                            'type': 'input_validation_weakness',
                            'severity': 'MEDIUM',
                            'parameter': input_name,
                            'description': f'{description} in field {input_name}',
                            'evidence': f'Form input: {input_name}',
                            'recommendation': 'Implement proper input validation and sanitization'
                        })


def test_symbolic_execution(base_url: str) -> List[Dict[str, Any]]:
    """
    Test for vulnerabilities using symbolic execution techniques

    Args:
        base_url: Base URL to test

    Returns:
        List of discovered vulnerabilities
    """
    executor = SymbolicExecutor(base_url)

    # Analyze main page
    vulnerabilities = executor.analyze_webpage(base_url)

    # Try to discover additional pages to analyze
    try:
        response = requests.get(base_url, timeout=10)
        if response.status_code == 200:
            # Look for links to other pages
            link_pattern = r'href=["\']([^"\']+)["\']'
            links = re.findall(link_pattern, response.text, re.IGNORECASE)

            for link in links[:5]:  # Limit to first 5 links to avoid excessive scanning
                if not link.startswith(('http://', 'https://', 'mailto:', 'javascript:')):
                    full_url = urljoin(base_url, link)
                    if urlparse(full_url).netloc == urlparse(base_url).netloc:  # Same domain
                        additional_vulns = executor.analyze_webpage(full_url)
                        vulnerabilities.extend(additional_vulns)

    except Exception:
        pass  # Continue with main analysis

    return vulnerabilities
