"""
Decompilation and Reverse Engineering Engine for Dynamic Analysis Agent

This module provides capabilities to decompile binaries back to source-like code
for analysis and understanding of compiled applications.
"""

import re
import os
import subprocess
import tempfile
from typing import List, Dict, Any, Optional, Tuple
import hashlib

class Decompiler:
    """Decompilation engine for various binary formats"""

    def __init__(self):
        self.supported_formats = {
            'python': ['.pyc', '.pyo'],
            'java': ['.class', '.jar'],
            'dotnet': ['.exe', '.dll'],
            'native': ['.exe', '.dll', '.so', '.dylib', '.elf']
        }
        self.temp_dir = tempfile.mkdtemp()

    def decompile_file(self, file_path: str, file_url: str) -> Optional[Dict[str, Any]]:
        """
        Attempt to decompile a file and analyze the results

        Args:
            file_path: Local path to the file
            file_url: Original URL of the file

        Returns:
            Dict containing decompilation results and analysis
        """
        file_ext = os.path.splitext(file_path)[1].lower()

        # Determine file type and decompilation method
        if file_ext in self.supported_formats['python']:
            return self._decompile_python(file_path, file_url)
        elif file_ext in ['.class']:
            return self._decompile_java_class(file_path, file_url)
        elif file_ext == '.jar':
            return self._decompile_jar(file_path, file_url)
        elif file_ext in ['.exe', '.dll'] and self._is_dotnet_file(file_path):
            return self._decompile_dotnet(file_path, file_url)
        else:
            # Try generic analysis for unknown binary formats
            return self._analyze_generic_binary(file_path, file_url)

    def _decompile_python(self, file_path: str, file_url: str) -> Optional[Dict[str, Any]]:
        """Decompile Python bytecode"""
        try:
            # Use uncompyle6 or similar tool
            result = subprocess.run(['uncompyle6', '-o', self.temp_dir, file_path],
                                  capture_output=True, text=True, timeout=30)

            if result.returncode == 0:
                # Find the decompiled file
                decompiled_files = []
                for root, dirs, files in os.walk(self.temp_dir):
                    for file in files:
                        if file.endswith('.py'):
                            decompiled_files.append(os.path.join(root, file))

                if decompiled_files:
                    # Analyze the decompiled code
                    return self._analyze_decompiled_python(decompiled_files[0], file_url)

        except (subprocess.TimeoutExpired, FileNotFoundError):
            # Try alternative method with pycdc
            try:
                result = subprocess.run(['pycdc', file_path],
                                      capture_output=True, text=True, timeout=30)

                if result.returncode == 0:
                    return self._analyze_decompiled_code(result.stdout, file_url, 'python')

            except (subprocess.TimeoutExpired, FileNotFoundError):
                pass

        return None

    def _decompile_java_class(self, file_path: str, file_url: str) -> Optional[Dict[str, Any]]:
        """Decompile Java class file"""
        try:
            # Use javap for basic analysis
            result = subprocess.run(['javap', '-c', '-l', '-p', file_path],
                                  capture_output=True, text=True, timeout=30)

            if result.returncode == 0:
                return self._analyze_decompiled_code(result.stdout, file_url, 'java')

        except (subprocess.TimeoutExpired, FileNotFoundError):
            pass

        return None

    def _decompile_jar(self, file_path: str, file_url: str) -> Optional[Dict[str, Any]]:
        """Analyze JAR file contents"""
        try:
            # Extract JAR contents
            extract_dir = os.path.join(self.temp_dir, 'jar_extract')
            os.makedirs(extract_dir, exist_ok=True)

            result = subprocess.run(['unzip', '-q', file_path, '-d', extract_dir],
                                  capture_output=True, text=True, timeout=30)

            if result.returncode == 0:
                # Find class files and analyze
                vulnerabilities = []
                for root, dirs, files in os.walk(extract_dir):
                    for file in files:
                        if file.endswith('.class'):
                            class_path = os.path.join(root, file)
                            class_analysis = self._decompile_java_class(class_path, file_url)
                            if class_analysis and class_analysis.get('vulnerabilities'):
                                vulnerabilities.extend(class_analysis['vulnerabilities'])

                return {
                    'format': 'jar',
                    'url': file_url,
                    'vulnerabilities': vulnerabilities,
                    'decompiled': True
                }

        except (subprocess.TimeoutExpired, FileNotFoundError):
            pass

        return None

    def _is_dotnet_file(self, file_path: str) -> bool:
        """Check if a PE file is a .NET assembly"""
        try:
            with open(file_path, 'rb') as f:
                # Look for .NET metadata
                data = f.read()
                return b'BSJB' in data or b'mscoree.dll' in data.lower()
        except Exception:
            return False

    def _decompile_dotnet(self, file_path: str, file_url: str) -> Optional[Dict[str, Any]]:
        """Decompile .NET assembly"""
        try:
            # Use ildasm for IL disassembly
            result = subprocess.run(['ildasm', file_path, '/text'],
                                  capture_output=True, text=True, timeout=30)

            if result.returncode == 0:
                return self._analyze_decompiled_code(result.stdout, file_url, 'dotnet')

        except (subprocess.TimeoutExpired, FileNotFoundError):
            pass

        return None

    def _analyze_generic_binary(self, file_path: str, file_url: str) -> Optional[Dict[str, Any]]:
        """Perform generic analysis on unknown binary formats"""
        try:
            # Extract strings and analyze
            result = subprocess.run(['strings', file_path],
                                  capture_output=True, text=True, timeout=30)

            if result.returncode == 0:
                return self._analyze_decompiled_code(result.stdout, file_url, 'binary')

        except (subprocess.TimeoutExpired, FileNotFoundError):
            pass

        return None

    def _analyze_decompiled_python(self, decompiled_file: str, file_url: str) -> Optional[Dict[str, Any]]:
        """Analyze decompiled Python code"""
        try:
            with open(decompiled_file, 'r', encoding='utf-8', errors='ignore') as f:
                code = f.read()

            return self._analyze_decompiled_code(code, file_url, 'python')

        except Exception:
            return None

    def _analyze_decompiled_code(self, code: str, file_url: str, language: str) -> Dict[str, Any]:
        """Analyze decompiled code for security vulnerabilities"""
        vulnerabilities = []

        # Common security patterns to look for
        security_patterns = {
            'python': [
                (r'eval\s*\([^)]+\)', 'CODE_INJECTION', 'CRITICAL', 'Code injection via eval()'),
                (r'exec\s*\([^)]+\)', 'CODE_EXECUTION', 'CRITICAL', 'Arbitrary code execution'),
                (r'pickle\.loads?\s*\([^)]+\)', 'DESERIALIZATION', 'HIGH', 'Unsafe deserialization'),
                (r'subprocess\.(?:call|Popen|run)\s*\([^)]*shell\s*=\s*True[^)]*\)', 'COMMAND_INJECTION', 'HIGH', 'Shell command injection'),
                (r'os\.system\s*\([^)]+\)', 'COMMAND_INJECTION', 'HIGH', 'System command execution'),
                (r'input\s*\(', 'UNSAFE_INPUT', 'MEDIUM', 'Unsafe input handling (Python 2 style)'),
                (r'hardcoded.*(?:password|secret|key)', 'HARDCODED_CREDENTIALS', 'HIGH', 'Hard-coded credentials'),
            ],
            'java': [
                (r'Runtime\.getRuntime\(\)\.exec\s*\([^)]+\)', 'COMMAND_INJECTION', 'HIGH', 'Command execution'),
                (r'ProcessBuilder\s*\([^)]+\)', 'COMMAND_INJECTION', 'HIGH', 'Process creation'),
                (r'ObjectInputStream\.readObject\s*\(\)', 'DESERIALIZATION', 'HIGH', 'Unsafe deserialization'),
                (r'SQL\s+.*(?:SELECT|INSERT|UPDATE|DELETE)', 'SQL_INJECTION', 'HIGH', 'Potential SQL injection'),
                (r'hardcoded.*(?:password|secret)', 'HARDCODED_CREDENTIALS', 'HIGH', 'Hard-coded credentials'),
            ],
            'dotnet': [
                (r'Eval\s*\([^)]+\)', 'CODE_INJECTION', 'CRITICAL', 'Code injection via Eval'),
                (r'Execute\s*\([^)]+\)', 'CODE_EXECUTION', 'CRITICAL', 'Code execution'),
                (r'Deserialize\s*\([^)]+\)', 'DESERIALIZATION', 'HIGH', 'Unsafe deserialization'),
                (r'SqlCommand\s*\([^)]+\)', 'SQL_INJECTION', 'HIGH', 'Potential SQL injection'),
                (r'Process\.Start\s*\([^)]+\)', 'COMMAND_INJECTION', 'HIGH', 'Process execution'),
            ],
            'binary': [
                (r'/bin/sh', 'SHELL_ACCESS', 'HIGH', 'Shell access detected'),
                (r'/bin/bash', 'SHELL_ACCESS', 'HIGH', 'Bash shell access detected'),
                (r'password', 'CREDENTIALS', 'MEDIUM', 'Potential credentials in binary'),
                (r'admin', 'PRIVILEGED_ACCESS', 'LOW', 'Privileged access references'),
            ]
        }

        patterns = security_patterns.get(language, security_patterns['binary'])

        lines = code.split('\n')
        for line_num, line in enumerate(lines, 1):
            line = line.strip()
            if not line:
                continue

            for pattern, vuln_type, severity, description in patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    vulnerabilities.append({
                        'type': vuln_type.lower(),
                        'severity': severity,
                        'description': description,
                        'evidence': f'Line {line_num}: {line[:100]}...',
                        'file_url': file_url,
                        'language': language,
                        'recommendation': self._get_recommendation(vuln_type)
                    })

                    # Limit findings per file
                    if len(vulnerabilities) >= 20:
                        break

            if len(vulnerabilities) >= 20:
                break

        return {
            'format': language,
            'url': file_url,
            'decompiled': True,
            'vulnerabilities': vulnerabilities,
            'code_sample': code[:1000]  # First 1000 chars as sample
        }

    def _get_recommendation(self, vuln_type: str) -> str:
        """Get security recommendation based on vulnerability type"""
        recommendations = {
            'CODE_INJECTION': 'Avoid using eval() or similar code execution functions with user input',
            'CODE_EXECUTION': 'Never execute user-controlled code',
            'DESERIALIZATION': 'Use safe deserialization methods or validate input strictly',
            'COMMAND_INJECTION': 'Use parameterized commands or validate/sanitize input',
            'SQL_INJECTION': 'Use prepared statements and parameterized queries',
            'HARDCODED_CREDENTIALS': 'Store credentials securely, never hard-code them',
            'UNSAFE_INPUT': 'Validate and sanitize all user input',
            'SHELL_ACCESS': 'Limit shell access and validate commands',
            'CREDENTIALS': 'Remove sensitive information from binaries',
            'PRIVILEGED_ACCESS': 'Implement proper access controls'
        }

        return recommendations.get(vuln_type, 'Review and fix the security issue')

    def cleanup(self):
        """Clean up temporary files"""
        try:
            import shutil
            shutil.rmtree(self.temp_dir, ignore_errors=True)
        except Exception:
            pass


class ReverseEngineeringAnalyzer:
    """Reverse engineering analysis for binaries"""

    def __init__(self, base_url: str):
        self.base_url = base_url
        self.decompiler = Decompiler()
        self.vulnerabilities: List[Dict[str, Any]] = []

    def analyze_binaries(self) -> List[Dict[str, Any]]:
        """
        Analyze application binaries using reverse engineering techniques

        Returns:
            List of discovered vulnerabilities
        """
        # Discover binary files
        binary_urls = self._discover_binary_files()

        for binary_url in binary_urls:
            self._analyze_binary_file(binary_url)

        self.decompiler.cleanup()
        return self.vulnerabilities

    def _discover_binary_files(self) -> List[str]:
        """Discover binary files in the application"""
        binary_urls = []

        try:
            # Import here to avoid circular imports
            from ..utils import make_request

            response = make_request(self.base_url)
            if not response:
                return binary_urls

            content = response.text

            # Look for binary file links
            binary_extensions = [
                '.exe', '.dll', '.so', '.dylib', '.bin', '.elf',
                '.jar', '.war', '.ear', '.class', '.pyc', '.pyo'
            ]

            link_pattern = r'href=["\']([^"\']+)["\']'
            links = re.findall(link_pattern, content, re.IGNORECASE)

            for link in links:
                if not link.startswith(('http://', 'https://', 'mailto:', 'javascript:')):
                    from urllib.parse import urljoin
                    full_url = urljoin(self.base_url, link)

                    # Check if it looks like a binary file
                    if any(link.lower().endswith(ext) for ext in binary_extensions):
                        binary_urls.append(full_url)

        except Exception:
            pass

        return binary_urls[:5]  # Limit to avoid excessive analysis

    def _analyze_binary_file(self, binary_url: str):
        """Analyze a single binary file"""
        try:
            # Download the file
            import requests
            response = requests.get(binary_url, timeout=30, stream=True)
            if response.status_code != 200:
                return

            # Save to temporary file
            temp_file = tempfile.NamedTemporaryFile(delete=False)
            try:
                with temp_file:
                    for chunk in response.iter_content(chunk_size=8192):
                        temp_file.write(chunk)

                temp_file_path = temp_file.name

                # Attempt decompilation
                decompilation_result = self.decompiler.decompile_file(temp_file_path, binary_url)

                if decompilation_result:
                    # Process the results
                    if decompilation_result.get('vulnerabilities'):
                        self.vulnerabilities.extend(decompilation_result['vulnerabilities'])

                    # Additional analysis based on decompiled code
                    self._analyze_decompiled_structure(decompilation_result)

            finally:
                # Clean up temp file
                try:
                    os.unlink(temp_file_path)
                except Exception:
                    pass

        except Exception as e:
            pass

    def _analyze_decompiled_structure(self, decompilation_result: Dict[str, Any]):
        """Analyze the structure of decompiled code"""
        if not decompilation_result.get('decompiled'):
            return

        language = decompilation_result.get('format', 'unknown')
        code_sample = decompilation_result.get('code_sample', '')

        # Look for architectural issues
        if language == 'python':
            self._analyze_python_architecture(code_sample, decompilation_result['url'])
        elif language == 'java':
            self._analyze_java_architecture(code_sample, decompilation_result['url'])
        elif language == 'dotnet':
            self._analyze_dotnet_architecture(code_sample, decompilation_result['url'])

    def _analyze_python_architecture(self, code: str, file_url: str):
        """Analyze Python code architecture"""
        # Check for insecure imports
        insecure_imports = [
            'pickle', 'marshal', 'shelve',  # Deserialization risks
            'subprocess', 'os.system',  # Command execution
            'eval', 'exec', 'compile',  # Code execution
        ]

        for insecure_import in insecure_imports:
            if re.search(rf'\bimport\s+{re.escape(insecure_import)}', code) or \
               re.search(rf'\bfrom\s+{re.escape(insecure_import)}', code):
                self.vulnerabilities.append({
                    'type': 'insecure_import',
                    'severity': 'MEDIUM',
                    'description': f'Insecure import detected: {insecure_import}',
                    'evidence': f'Import in decompiled code (URL: {file_url})',
                    'recommendation': 'Review usage of insecure modules'
                })

    def _analyze_java_architecture(self, code: str, file_url: str):
        """Analyze Java code architecture"""
        # Check for common Java security issues
        security_issues = [
            (r'Runtime\.getRuntime\(\)', 'COMMAND_EXECUTION', 'Runtime execution detected'),
            (r'ProcessBuilder', 'COMMAND_EXECUTION', 'Process builder usage'),
            (r'ObjectInputStream', 'DESERIALIZATION', 'Object deserialization'),
            (r'Statement\s+.*execute', 'SQL_INJECTION', 'Direct SQL execution'),
        ]

        for pattern, vuln_type, description in security_issues:
            if re.search(pattern, code, re.IGNORECASE):
                self.vulnerabilities.append({
                    'type': vuln_type.lower(),
                    'severity': 'HIGH',
                    'description': description,
                    'evidence': f'Pattern in decompiled Java code (URL: {file_url})',
                    'recommendation': 'Review and secure the implementation'
                })

    def _analyze_dotnet_architecture(self, code: str, file_url: str):
        """Analyze .NET code architecture"""
        # Check for common .NET security issues
        security_issues = [
            (r'Eval\s*\(', 'CODE_INJECTION', 'Code evaluation detected'),
            (r'Execute\s*\(', 'CODE_EXECUTION', 'Code execution detected'),
            (r'Deserialize\s*\(', 'DESERIALIZATION', 'Unsafe deserialization'),
            (r'SqlCommand', 'SQL_INJECTION', 'SQL command usage'),
        ]

        for pattern, vuln_type, description in security_issues:
            if re.search(pattern, code, re.IGNORECASE):
                self.vulnerabilities.append({
                    'type': vuln_type.lower(),
                    'severity': 'HIGH',
                    'description': description,
                    'evidence': f'Pattern in decompiled .NET code (URL: {file_url})',
                    'recommendation': 'Review and secure the implementation'
                })


def test_decompilation(base_url: str) -> List[Dict[str, Any]]:
    """
    Test for vulnerabilities using decompilation and reverse engineering

    Args:
        base_url: Base URL to test

    Returns:
        List of discovered vulnerabilities
    """
    analyzer = ReverseEngineeringAnalyzer(base_url)
    return analyzer.analyze_binaries()
