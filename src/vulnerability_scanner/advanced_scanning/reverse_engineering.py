"""
Reverse Engineering Integration for Dynamic Analysis Agent

This module integrates various reverse engineering tools and techniques
to analyze compiled applications and binaries for security vulnerabilities.
"""

import os
import re
import subprocess
import tempfile
import requests
from typing import List, Dict, Any, Optional, Tuple, Set
from urllib.parse import urljoin, urlparse
import hashlib
import json

class ReverseEngineeringTool:
    """Base class for reverse engineering tools"""

    def __init__(self, name: str, command: List[str], description: str):
        self.name = name
        self.command = command
        self.description = description
        self.available = self._check_availability()

    def _check_availability(self) -> bool:
        """Check if the tool is available on the system"""
        try:
            if self.command:
                result = subprocess.run([self.command[0], '--help' if len(self.command) == 1 else self.command[1]],
                                      capture_output=True, timeout=5)
                return result.returncode == 0
        except (subprocess.TimeoutExpired, FileNotFoundError, OSError):
            pass
        return False

    def run(self, file_path: str, **kwargs) -> Optional[Dict[str, Any]]:
        """Run the tool on a file"""
        if not self.available:
            return None

        try:
            cmd = self.command + [file_path]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)

            if result.returncode == 0:
                return {
                    'tool': self.name,
                    'output': result.stdout,
                    'error': result.stderr,
                    'success': True
                }
            else:
                return {
                    'tool': self.name,
                    'output': result.stdout,
                    'error': result.stderr,
                    'success': False
                }
        except (subprocess.TimeoutExpired, Exception) as e:
            return {
                'tool': self.name,
                'error': str(e),
                'success': False
            }


class ReverseEngineeringSuite:
    """Suite of reverse engineering tools"""

    def __init__(self):
        self.tools = self._initialize_tools()
        self.temp_dir = tempfile.mkdtemp()

    def _initialize_tools(self) -> Dict[str, ReverseEngineeringTool]:
        """Initialize available reverse engineering tools"""
        tools = {}

        # Binary analysis tools
        tools['file'] = ReverseEngineeringTool(
            'file', ['file'], 'File type identification'
        )

        tools['strings'] = ReverseEngineeringTool(
            'strings', ['strings'], 'Extract strings from binaries'
        )

        tools['readelf'] = ReverseEngineeringTool(
            'readelf', ['readelf', '-a'], 'ELF file analysis'
        )

        tools['objdump'] = ReverseEngineeringTool(
            'objdump', ['objdump', '-d'], 'Disassemble binary'
        )

        tools['nm'] = ReverseEngineeringTool(
            'nm', ['nm'], 'List symbols from object files'
        )

        # Java tools
        tools['javap'] = ReverseEngineeringTool(
            'javap', ['javap', '-c'], 'Java class file disassembler'
        )

        tools['jar'] = ReverseEngineeringTool(
            'jar', ['jar', 'tf'], 'List JAR file contents'
        )

        # Python tools
        tools['uncompyle6'] = ReverseEngineeringTool(
            'uncompyle6', ['uncompyle6'], 'Python bytecode decompiler'
        )

        tools['pycdc'] = ReverseEngineeringTool(
            'pycdc', ['pycdc'], 'Alternative Python decompiler'
        )

        # .NET tools
        tools['ildasm'] = ReverseEngineeringTool(
            'ildasm', ['ildasm'], 'MSIL disassembler'
        )

        tools['monodis'] = ReverseEngineeringTool(
            'monodis', ['monodis'], 'Mono CIL disassembler'
        )

        return tools

    def analyze_file(self, file_path: str, file_url: str) -> Dict[str, Any]:
        """
        Analyze a file using available reverse engineering tools

        Args:
            file_path: Local path to the file
            file_url: Original URL of the file

        Returns:
            Analysis results from all available tools
        """
        results = {
            'file_url': file_url,
            'file_path': file_path,
            'file_info': self._get_file_info(file_path),
            'tool_results': {},
            'vulnerabilities': []
        }

        # Determine file type
        file_type = self._identify_file_type(file_path)

        # Run appropriate tools based on file type
        applicable_tools = self._get_applicable_tools(file_type)

        for tool_name, tool in applicable_tools.items():
            tool_result = tool.run(file_path)
            if tool_result:
                results['tool_results'][tool_name] = tool_result

                # Analyze tool output for vulnerabilities
                vulns = self._analyze_tool_output(tool_name, tool_result, file_type)
                results['vulnerabilities'].extend(vulns)

        return results

    def _get_file_info(self, file_path: str) -> Dict[str, Any]:
        """Get basic file information"""
        try:
            stat = os.stat(file_path)
            file_hash = self._calculate_file_hash(file_path)

            return {
                'size': stat.st_size,
                'permissions': oct(stat.st_mode),
                'sha256': file_hash,
                'exists': True
            }
        except Exception as e:
            return {
                'error': str(e),
                'exists': False
            }

    def _identify_file_type(self, file_path: str) -> str:
        """Identify the file type"""
        try:
            with open(file_path, 'rb') as f:
                header = f.read(64)

            # Check file signatures
            if header.startswith(b'\x7fELF'):
                return 'elf'
            elif header.startswith(b'MZ'):
                # Could be PE or .NET
                if b'BSJB' in header or b'mscoree.dll' in header.lower():
                    return 'dotnet'
                else:
                    return 'pe'
            elif header.startswith(b'PK\x03\x04'):
                return 'jar'
            elif header.startswith(b'\xca\xfe\xba\xbe'):
                return 'java_class'
            elif header.startswith(b'PK\x03\x04'):  # JAR files also start with PK
                return 'jar'
            elif file_path.endswith(('.pyc', '.pyo')):
                return 'python_bytecode'
            else:
                return 'unknown'

        except Exception:
            return 'unknown'

    def _get_applicable_tools(self, file_type: str) -> Dict[str, ReverseEngineeringTool]:
        """Get tools applicable to the file type"""
        tool_mapping = {
            'elf': ['file', 'strings', 'readelf', 'objdump', 'nm'],
            'pe': ['file', 'strings', 'objdump', 'nm'],
            'dotnet': ['file', 'strings', 'ildasm', 'monodis'],
            'jar': ['file', 'jar'],
            'java_class': ['file', 'javap'],
            'python_bytecode': ['file', 'strings', 'uncompyle6', 'pycdc'],
            'unknown': ['file', 'strings']
        }

        applicable_names = tool_mapping.get(file_type, ['file', 'strings'])
        return {name: self.tools[name] for name in applicable_names if name in self.tools}

    def _calculate_file_hash(self, file_path: str) -> str:
        """Calculate SHA256 hash of file"""
        try:
            import hashlib
            hash_sha256 = hashlib.sha256()
            with open(file_path, 'rb') as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hash_sha256.update(chunk)
            return hash_sha256.hexdigest()
        except Exception:
            return ""

    def _analyze_tool_output(self, tool_name: str, tool_result: Dict[str, Any],
                           file_type: str) -> List[Dict[str, Any]]:
        """Analyze tool output for security vulnerabilities"""
        vulnerabilities = []

        if not tool_result.get('success') or not tool_result.get('output'):
            return vulnerabilities

        output = tool_result['output']

        # Tool-specific analysis
        if tool_name == 'strings':
            vulnerabilities.extend(self._analyze_strings_output(output))
        elif tool_name == 'readelf':
            vulnerabilities.extend(self._analyze_readelf_output(output))
        elif tool_name == 'objdump':
            vulnerabilities.extend(self._analyze_objdump_output(output))
        elif tool_name == 'javap':
            vulnerabilities.extend(self._analyze_javap_output(output))
        elif tool_name == 'uncompyle6' or tool_name == 'pycdc':
            vulnerabilities.extend(self._analyze_python_decompiled(output))

        return vulnerabilities

    def _analyze_strings_output(self, output: str) -> List[Dict[str, Any]]:
        """Analyze strings output for vulnerabilities"""
        vulnerabilities = []
        lines = output.split('\n')

        sensitive_patterns = [
            (r'password', 'HARD_CODED_PASSWORD', 'HIGH', 'Hard-coded password in binary'),
            (r'api[_-]?key', 'HARD_CODED_API_KEY', 'HIGH', 'Hard-coded API key in binary'),
            (r'secret', 'HARD_CODED_SECRET', 'HIGH', 'Hard-coded secret in binary'),
            (r'private[_-]?key', 'PRIVATE_KEY_EXPOSED', 'CRITICAL', 'Private key exposed in binary'),
            (r'/etc/passwd', 'SENSITIVE_FILE_ACCESS', 'MEDIUM', 'References to sensitive system files'),
            (r'eval\s*\(', 'CODE_EVALUATION', 'HIGH', 'Code evaluation functions detected'),
            (r'system\s*\(', 'SYSTEM_CALLS', 'MEDIUM', 'System command calls detected'),
            (r'chmod\s+777', 'INSECURE_PERMISSIONS', 'LOW', 'World-writable permissions detected'),
        ]

        for line in lines:
            line = line.strip()
            if len(line) < 4:  # Skip very short strings
                continue

            for pattern, vuln_type, severity, description in sensitive_patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    vulnerabilities.append({
                        'type': vuln_type.lower(),
                        'severity': severity,
                        'description': description,
                        'evidence': f'String: {line[:100]}...',
                        'tool': 'strings',
                        'recommendation': 'Remove sensitive information from binaries'
                    })

                    # Limit findings
                    if len(vulnerabilities) >= 10:
                        break

            if len(vulnerabilities) >= 10:
                break

        return vulnerabilities

    def _analyze_readelf_output(self, output: str) -> List[Dict[str, Any]]:
        """Analyze readelf output for vulnerabilities"""
        vulnerabilities = []

        # Check for executable stack
        if 'GNU_STACK' in output and 'RWE' in output:
            vulnerabilities.append({
                'type': 'executable_stack',
                'severity': 'MEDIUM',
                'description': 'Executable stack detected (potential buffer overflow vulnerability)',
                'evidence': 'GNU_STACK with RWE permissions',
                'tool': 'readelf',
                'recommendation': 'Use non-executable stack where possible'
            })

        # Check for missing RELRO
        if 'RELRO' not in output or 'PARTIAL' in output:
            vulnerabilities.append({
                'type': 'missing_relro',
                'severity': 'LOW',
                'description': 'Partial or missing RELRO protection',
                'evidence': 'RELRO not fully enabled',
                'tool': 'readelf',
                'recommendation': 'Enable full RELRO protection'
            })

        # Check for missing stack canary
        if '__stack_chk_fail' not in output:
            vulnerabilities.append({
                'type': 'missing_stack_canary',
                'severity': 'MEDIUM',
                'description': 'Stack canary protection not detected',
                'evidence': 'No stack canary functions found',
                'tool': 'readelf',
                'recommendation': 'Enable stack canary protection (-fstack-protector)'
            })

        return vulnerabilities

    def _analyze_objdump_output(self, output: str) -> List[Dict[str, Any]]:
        """Analyze objdump output for vulnerabilities"""
        vulnerabilities = []

        # Look for dangerous functions
        dangerous_functions = [
            'strcpy', 'strcat', 'sprintf', 'gets', 'system', 'exec',
            'popen', 'scanf', 'sscanf', 'fscanf'
        ]

        for func in dangerous_functions:
            if func in output:
                vulnerabilities.append({
                    'type': 'dangerous_function',
                    'severity': 'MEDIUM',
                    'description': f'Potentially dangerous function detected: {func}',
                    'evidence': f'Function call to {func}',
                    'tool': 'objdump',
                    'recommendation': 'Use safer alternatives (e.g., strcpy -> strncpy)'
                })

        # Look for format string vulnerabilities
        if re.search(r'printf\s*\([^%]*%[^%]*\$\s*\d+', output):
            vulnerabilities.append({
                'type': 'format_string',
                'severity': 'HIGH',
                'description': 'Potential format string vulnerability',
                'evidence': 'Format string with positional arguments',
                'tool': 'objdump',
                'recommendation': 'Validate format strings and arguments'
            })

        return vulnerabilities

    def _analyze_javap_output(self, output: str) -> List[Dict[str, Any]]:
        """Analyze javap output for vulnerabilities"""
        vulnerabilities = []

        # Look for insecure patterns in Java bytecode
        insecure_patterns = [
            ('invokedynamic', 'DYNAMIC_INVOKE', 'MEDIUM', 'Dynamic invocation detected'),
            ('java/lang/Runtime', 'RUNTIME_EXEC', 'HIGH', 'Runtime execution detected'),
            ('java/lang/ProcessBuilder', 'PROCESS_BUILDER', 'HIGH', 'Process builder usage'),
            ('java/io/ObjectInputStream', 'DESERIALIZATION', 'HIGH', 'Object deserialization'),
        ]

        for pattern, vuln_type, severity, description in insecure_patterns:
            if pattern in output:
                vulnerabilities.append({
                    'type': vuln_type.lower(),
                    'severity': severity,
                    'description': description,
                    'evidence': f'Pattern: {pattern}',
                    'tool': 'javap',
                    'recommendation': 'Review usage of potentially dangerous APIs'
                })

        return vulnerabilities

    def _analyze_python_decompiled(self, output: str) -> List[Dict[str, Any]]:
        """Analyze decompiled Python code"""
        vulnerabilities = []

        # Similar to decompilation.py analysis but from tool output
        dangerous_patterns = [
            (r'eval\s*\(', 'CODE_INJECTION', 'CRITICAL', 'Code injection via eval()'),
            (r'exec\s*\(', 'CODE_EXECUTION', 'CRITICAL', 'Arbitrary code execution'),
            (r'pickle\.loads?', 'DESERIALIZATION', 'HIGH', 'Unsafe pickle deserialization'),
            (r'os\.system\s*\(', 'COMMAND_INJECTION', 'HIGH', 'System command execution'),
        ]

        for pattern, vuln_type, severity, description in dangerous_patterns:
            if re.search(pattern, output, re.IGNORECASE):
                vulnerabilities.append({
                    'type': vuln_type.lower(),
                    'severity': severity,
                    'description': description,
                    'evidence': f'Pattern in decompiled code: {pattern}',
                    'tool': 'decompiler',
                    'recommendation': 'Avoid using dangerous functions with user input'
                })

        return vulnerabilities

    def cleanup(self):
        """Clean up temporary files"""
        try:
            import shutil
            shutil.rmtree(self.temp_dir, ignore_errors=True)
        except Exception:
            pass


class ReverseEngineeringAnalyzer:
    """Main reverse engineering analyzer"""

    def __init__(self, base_url: str):
        self.base_url = base_url
        self.suite = ReverseEngineeringSuite()
        self.vulnerabilities: List[Dict[str, Any]] = []

    def analyze_application(self) -> List[Dict[str, Any]]:
        """
        Perform comprehensive reverse engineering analysis

        Returns:
            List of discovered vulnerabilities
        """
        # Discover binary files
        binary_urls = self._discover_binary_files()

        for binary_url in binary_urls:
            analysis_result = self._analyze_binary_url(binary_url)
            if analysis_result:
                self.vulnerabilities.extend(analysis_result.get('vulnerabilities', []))

        self.suite.cleanup()
        return self.vulnerabilities

    def _discover_binary_files(self) -> List[str]:
        """Discover binary files in the application"""
        binary_urls = []

        try:
            # Import here to avoid circular imports
            from ..utils import make_request

            response = make_request(self.base_url)
            if not response:
                return binary_urls

            content = response.text

            # Look for binary file links
            binary_extensions = [
                '.exe', '.dll', '.so', '.dylib', '.bin', '.elf',
                '.jar', '.war', '.ear', '.class', '.pyc', '.pyo'
            ]

            link_pattern = r'href=["\']([^"\']+)["\']'
            links = re.findall(link_pattern, content, re.IGNORECASE)

            for link in links:
                if not link.startswith(('http://', 'https://', 'mailto:', 'javascript:')):
                    from urllib.parse import urljoin
                    full_url = urljoin(self.base_url, link)

                    # Check if it looks like a binary file
                    if any(link.lower().endswith(ext) for ext in binary_extensions):
                        binary_urls.append(full_url)

                    # Also check common binary paths
                    binary_paths = ['/static/', '/assets/', '/bin/', '/lib/', '/download/']
                    if any(binary_path in link for binary_path in binary_paths):
                        binary_urls.append(full_url)

        except Exception:
            pass

        return binary_urls[:5]  # Limit to avoid excessive analysis

    def _analyze_binary_url(self, binary_url: str) -> Optional[Dict[str, Any]]:
        """Analyze a binary file from URL"""
        try:
            # Download the file
            response = requests.get(binary_url, timeout=30, stream=True)
            if response.status_code != 200:
                return None

            # Save to temporary file
            temp_file = tempfile.NamedTemporaryFile(delete=False)
            try:
                with temp_file:
                    for chunk in response.iter_content(chunk_size=8192):
                        temp_file.write(chunk)

                temp_file_path = temp_file.name

                # Analyze with reverse engineering suite
                analysis_result = self.suite.analyze_file(temp_file_path, binary_url)

                return analysis_result

            finally:
                # Clean up temp file
                try:
                    os.unlink(temp_file_path)
                except Exception:
                    pass

        except Exception:
            return None


def test_reverse_engineering(base_url: str) -> List[Dict[str, Any]]:
    """
    Test for vulnerabilities using reverse engineering techniques

    Args:
        base_url: Base URL to test

    Returns:
        List of discovered vulnerabilities
    """
    analyzer = ReverseEngineeringAnalyzer(base_url)
    return analyzer.analyze_application()
