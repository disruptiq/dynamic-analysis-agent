"""
Broken Authentication and Session Management testing for the Dynamic Analysis Agent.
"""

import requests
from urllib.parse import urljoin
import time

def test_broken_authentication(base_url):
    """
    Test for broken authentication and session management vulnerabilities.

    Args:
        base_url (str): Base URL to test

    Returns:
        list: List of detected vulnerabilities
    """
    vulnerabilities = []

    # Test for common authentication endpoints
    auth_endpoints = [
        urljoin(base_url, "/login"),
        urljoin(base_url, "/signin"),
        urljoin(base_url, "/auth"),
        urljoin(base_url, "/authenticate"),
        urljoin(base_url, "/api/login"),
        urljoin(base_url, "/api/auth")
    ]

    # Test for weak password policies
    weak_credentials = [
        ("admin", "admin"),
        ("admin", "password"),
        ("admin", "123456"),
        ("admin", ""),
        ("root", "root"),
        ("user", "user"),
        ("test", "test"),
        ("", "admin"),
        ("admin", "admin123")
    ]

    for endpoint in auth_endpoints:
        try:
            # First, get the login page to understand the form structure
            response = requests.get(endpoint, timeout=5)
            if response.status_code != 200:
                continue

            content = response.text.lower()

            # Test for default/weak credentials
            if 'password' in content and 'username' in content:
                for username, password in weak_credentials:
                    try:
                        data = {"username": username, "password": password, "user": username, "pass": password}
                        auth_response = requests.post(endpoint, data=data, timeout=5, allow_redirects=True)

                        # Check if login was successful (look for success indicators)
                        success_indicators = [
                            "welcome", "logged in", "dashboard", "profile",
                            "logout", "sign out", "my account"
                        ]

                        if auth_response.status_code in [200, 302] and any(indicator in auth_response.text.lower() for indicator in success_indicators):
                            vulnerabilities.append({
                                "type": "Broken Authentication - Weak Credentials",
                                "endpoint": endpoint,
                                "payload": f"Username: {username}, Password: {password}",
                                "method": "POST",
                                "evidence": f"Successful login with weak credentials: {username}/{password}"
                            })

                    except requests.RequestException:
                        continue

        except requests.RequestException:
            continue

    # Test for session fixation
    session_fixation_url = urljoin(base_url, "/session-fixation-test")
    try:
        # Try to set a session cookie
        cookies = {"PHPSESSID": "test123", "JSESSIONID": "test123", "session": "test123"}
        response = requests.get(urljoin(base_url, "/"), cookies=cookies, timeout=5)

        # If the application accepts arbitrary session IDs, it might be vulnerable
        if response.status_code == 200 and any(cookie in str(response.cookies) for cookie in cookies.keys()):
            vulnerabilities.append({
                "type": "Broken Authentication - Session Fixation",
                "endpoint": base_url,
                "payload": "PHPSESSID=test123",
                "method": "GET",
                "evidence": "Application accepts arbitrary session IDs"
            })

    except requests.RequestException:
        pass

    # Test for concurrent session handling
    concurrent_url = urljoin(base_url, "/concurrent-test")
    try:
        # Make multiple simultaneous requests to test session handling
        import threading
        results = []

        def make_request():
            try:
                response = requests.get(urljoin(base_url, "/dashboard"), timeout=5)
                results.append(response.status_code)
            except:
                results.append(500)

        threads = []
        for i in range(5):
            t = threading.Thread(target=make_request)
            threads.append(t)
            t.start()

        for t in threads:
            t.join()

        # If all requests succeed, concurrent sessions might not be handled properly
        if len(results) == 5 and all(code == 200 for code in results):
            vulnerabilities.append({
                "type": "Broken Authentication - Concurrent Sessions",
                "endpoint": urljoin(base_url, "/dashboard"),
                "payload": "Multiple concurrent requests",
                "method": "GET",
                "evidence": "Multiple concurrent sessions allowed without proper controls"
            })

    except Exception as e:
        pass

    return vulnerabilities
