"""
Security Headers validation for the Dynamic Analysis Agent.
"""

import requests
from urllib.parse import urljoin

def test_header_validations(base_url):
    """
    Test for missing or misconfigured security headers.

    Args:
        base_url (str): Base URL to test

    Returns:
        list: List of detected vulnerabilities
    """
    vulnerabilities = []

    # Endpoints to test for headers
    test_endpoints = [
        base_url,
        urljoin(base_url, "/login"),
        urljoin(base_url, "/admin"),
        urljoin(base_url, "/api"),
        urljoin(base_url, "/user"),
        urljoin(base_url, "/dashboard")
    ]

    for endpoint in test_endpoints:
        try:
            response = requests.get(endpoint, timeout=5)
            headers = response.headers

            # HSTS (HTTP Strict Transport Security)
            hsts = headers.get('Strict-Transport-Security', '')
            if not hsts:
                if endpoint.startswith('https://'):
                    vulnerabilities.append({
                        "type": "Missing HSTS Header",
                        "endpoint": endpoint,
                        "payload": "N/A",
                        "method": "GET",
                        "evidence": "HTTPS site missing Strict-Transport-Security header"
                    })
            else:
                # Check HSTS configuration
                if 'max-age=' in hsts:
                    max_age = hsts.split('max-age=')[1].split(';')[0]
                    try:
                        age_seconds = int(max_age)
                        if age_seconds < 31536000:  # Less than 1 year
                            vulnerabilities.append({
                                "type": "Weak HSTS Configuration",
                                "endpoint": endpoint,
                                "payload": f"max-age={age_seconds}",
                                "method": "GET",
                                "evidence": f"HSTS max-age too short: {age_seconds} seconds (recommended: 31536000+)"
                            })
                    except ValueError:
                        pass

                if 'includeSubDomains' not in hsts:
                    vulnerabilities.append({
                        "type": "Incomplete HSTS Configuration",
                        "endpoint": endpoint,
                        "payload": hsts,
                        "method": "GET",
                        "evidence": "HSTS missing includeSubDomains directive"
                    })

            # Content Security Policy
            csp = headers.get('Content-Security-Policy', '')
            if not csp:
                vulnerabilities.append({
                    "type": "Missing Content Security Policy",
                    "endpoint": endpoint,
                    "payload": "N/A",
                    "method": "GET",
                    "evidence": "No Content-Security-Policy header present"
                })
            else:
                # Check for overly permissive CSP
                if "'unsafe-inline'" in csp and "script-src" in csp:
                    vulnerabilities.append({
                        "type": "Permissive CSP Configuration",
                        "endpoint": endpoint,
                        "payload": csp,
                        "method": "GET",
                        "evidence": "CSP allows 'unsafe-inline' for scripts"
                    })

                if "'unsafe-eval'" in csp:
                    vulnerabilities.append({
                        "type": "Permissive CSP Configuration",
                        "endpoint": endpoint,
                        "payload": csp,
                        "method": "GET",
                        "evidence": "CSP allows 'unsafe-eval'"
                    })

                if "default-src *" in csp or "default-src '*'" in csp:
                    vulnerabilities.append({
                        "type": "Overly Permissive CSP",
                        "endpoint": endpoint,
                        "payload": csp,
                        "method": "GET",
                        "evidence": "CSP default-src allows all sources (*)"
                    })

            # X-Content-Type-Options
            x_content_type = headers.get('X-Content-Type-Options', '')
            if not x_content_type:
                vulnerabilities.append({
                    "type": "Missing X-Content-Type-Options",
                    "endpoint": endpoint,
                    "payload": "N/A",
                    "method": "GET",
                    "evidence": "Missing X-Content-Type-Options header (prevents MIME sniffing)"
                })
            elif x_content_type.lower() != 'nosniff':
                vulnerabilities.append({
                    "type": "Incorrect X-Content-Type-Options",
                    "endpoint": endpoint,
                    "payload": x_content_type,
                    "method": "GET",
                    "evidence": f"X-Content-Type-Options should be 'nosniff', got: {x_content_type}"
                })

            # Referrer-Policy
            referrer_policy = headers.get('Referrer-Policy', '')
            if not referrer_policy:
                vulnerabilities.append({
                    "type": "Missing Referrer-Policy",
                    "endpoint": endpoint,
                    "payload": "N/A",
                    "method": "GET",
                    "evidence": "Missing Referrer-Policy header"
                })
            else:
                weak_policies = ['unsafe-url', 'no-referrer-when-downgrade']
                if referrer_policy.lower() in weak_policies:
                    vulnerabilities.append({
                        "type": "Weak Referrer-Policy",
                        "endpoint": endpoint,
                        "payload": referrer_policy,
                        "method": "GET",
                        "evidence": f"Referrer-Policy '{referrer_policy}' may leak sensitive information"
                    })

            # Feature-Policy / Permissions-Policy
            feature_policy = headers.get('Feature-Policy') or headers.get('Permissions-Policy')
            if not feature_policy:
                vulnerabilities.append({
                    "type": "Missing Feature-Policy/Permissions-Policy",
                    "endpoint": endpoint,
                    "payload": "N/A",
                    "method": "GET",
                    "evidence": "Missing Feature-Policy or Permissions-Policy header"
                })

            # Subresource Integrity (for resources)
            # This is harder to check without parsing HTML, but we can check if SRI is mentioned
            content = response.text.lower()
            if '<script' in content and 'integrity=' not in content:
                # Check if external scripts lack integrity
                vulnerabilities.append({
                    "type": "Missing Subresource Integrity",
                    "endpoint": endpoint,
                    "payload": "N/A",
                    "method": "GET",
                    "evidence": "External scripts detected without integrity attribute"
                })

            # Check for other security headers
            security_headers = [
                'X-XSS-Protection',
                'X-Permitted-Cross-Domain-Policies',
                'Cross-Origin-Embedder-Policy',
                'Cross-Origin-Opener-Policy',
                'Cross-Origin-Resource-Policy'
            ]

            for header in security_headers:
                if not headers.get(header):
                    vulnerabilities.append({
                        "type": f"Missing {header}",
                        "endpoint": endpoint,
                        "payload": "N/A",
                        "method": "GET",
                        "evidence": f"Security header {header} is not present"
                    })

        except requests.RequestException:
            continue

    return vulnerabilities
