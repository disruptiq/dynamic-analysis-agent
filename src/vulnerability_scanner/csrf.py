"""
Cross-Site Request Forgery (CSRF) vulnerability testing for the Dynamic Analysis Agent.
"""

import requests
from urllib.parse import urljoin
import re

def test_csrf(base_url):
    """
    Test for Cross-Site Request Forgery (CSRF) vulnerabilities.

    Args:
        base_url (str): Base URL to test

    Returns:
        list: List of detected vulnerabilities
    """
    vulnerabilities = []

    # Get main page to check for CSRF tokens
    try:
        response = requests.get(base_url, timeout=5)
        main_page_content = response.text
    except requests.RequestException:
        main_page_content = ""

    # Look for forms that might be vulnerable to CSRF
    test_endpoints = [
        urljoin(base_url, "/change-password"),
        urljoin(base_url, "/update-profile"),
        urljoin(base_url, "/transfer"),
        urljoin(base_url, "/delete"),
        urljoin(base_url, "/admin/settings"),
        urljoin(base_url, "/api/user"),
        urljoin(base_url, "/user/settings")
    ]

    # CSRF protection indicators
    csrf_protections = [
        'csrf', 'token', '_token', 'authenticity_token',
        'xsrf-token', 'x-csrf-token', 'csrf_token',
        '__RequestVerificationToken', 'XSRF-TOKEN'
    ]

    for endpoint in test_endpoints:
        try:
            # First, get the form/page
            response = requests.get(endpoint, timeout=5)
            content = response.text.lower()

            # Check if endpoint exists and has forms
            if response.status_code == 200 and '<form' in content:
                has_csrf_protection = False

                # Check for CSRF tokens in form
                for protection in csrf_protections:
                    if protection.lower() in content:
                        has_csrf_protection = True
                        break

                # Check for SameSite cookie settings
                samesite_check = False
                if 'samesite' in str(response.cookies).lower():
                    samesite_check = True

                # Check for CORS headers
                cors_headers = [
                    'access-control-allow-origin',
                    'access-control-allow-credentials'
                ]
                has_cors = any(header in str(response.headers).lower() for header in cors_headers)

                # If no CSRF protection found, it's potentially vulnerable
                if not has_csrf_protection and not samesite_check:
                    vulnerabilities.append({
                        "type": "Cross-Site Request Forgery (CSRF)",
                        "endpoint": endpoint,
                        "payload": "N/A",
                        "method": "GET/POST",
                        "evidence": "No CSRF protection detected"
                    })

                # Check for dangerous CORS configuration
                if has_cors and 'access-control-allow-origin: *' in str(response.headers).lower():
                    vulnerabilities.append({
                        "type": "Cross-Site Request Forgery (CSRF)",
                        "endpoint": endpoint,
                        "payload": "CORS: *",
                        "method": "OPTIONS",
                        "evidence": "Dangerous CORS configuration allows all origins"
                    })

        except requests.RequestException:
            continue

    # Test for login CSRF (if login form exists)
    login_url = urljoin(base_url, "/login")
    try:
        response = requests.get(login_url, timeout=5)
        if response.status_code == 200 and '<form' in response.text.lower():
            content = response.text.lower()
            has_login_csrf = any(protection in content for protection in csrf_protections)

            if not has_login_csrf:
                vulnerabilities.append({
                    "type": "Login Cross-Site Request Forgery",
                    "endpoint": login_url,
                    "payload": "N/A",
                    "method": "POST",
                    "evidence": "Login form lacks CSRF protection"
                })

    except requests.RequestException:
        pass

    return vulnerabilities
