"""
Main vulnerability scanning orchestrator for the Dynamic Analysis Agent.
"""

import concurrent.futures
from .vulnerability_scanner.sql_injection import test_sql_injection
from .vulnerability_scanner.command_injection import test_command_injection
from .vulnerability_scanner.xxe import test_xxe
from .vulnerability_scanner.ssrf import test_ssrf
from .vulnerability_scanner.csrf import test_csrf
from .vulnerability_scanner.broken_auth import test_broken_authentication
from .vulnerability_scanner.sensitive_data import test_sensitive_data_exposure
from .vulnerability_scanner.broken_access import test_broken_access_control
from .vulnerability_scanner.security_misconfig import test_security_misconfiguration
from .vulnerability_scanner.known_vulns import test_known_vulnerabilities
from .vulnerability_scanner.insufficient_logging import test_insufficient_logging
from .vulnerability_scanner.race_conditions import test_race_conditions
from .vulnerability_scanner.buffer_overflow import test_buffer_overflow
from .vulnerability_scanner.format_string import test_format_string
from .vulnerability_scanner.ldap_injection import test_ldap_injection
from .vulnerability_scanner.xpath_injection import test_xpath_injection
from .vulnerability_scanner.nosql_injection import test_nosql_injection
from .vulnerability_scanner.graphql_injection import test_graphql_injection
from .vulnerability_scanner.template_injection import test_template_injection
from .vulnerability_scanner.ssti import test_ssti
# from .vulnerability_scanner.file_upload import test_file_upload_vulnerabilities  # Temporarily disabled
from .vulnerability_scanner.hpp import test_http_parameter_pollution
from .vulnerability_scanner.host_header import test_host_header_injection
from .vulnerability_scanner.http_smuggling import test_http_request_smuggling
from .vulnerability_scanner.insecure_deserialization import test_insecure_deserialization
from .vulnerability_scanner.cors import test_cors_misconfiguration
from .vulnerability_scanner.clickjacking import test_clickjacking
from .vulnerability_scanner.header_validations import test_header_validations
from .vulnerability_scanner.fuzzing import test_fuzzing
from .vulnerability_scanner.nmap_integration import test_nmap_integration

def test_vulnerabilities(base_url):
    """
    Test for comprehensive web vulnerabilities.

    Args:
        base_url (str): Base URL to test

    Returns:
        list: List of all detected vulnerabilities
    """
    all_vulnerabilities = []

    # Execute all vulnerability tests
    vulnerability_tests = [
        test_sql_injection,
        test_command_injection,
        test_xxe,
        test_ssrf,
        test_csrf,
        test_broken_authentication,
        test_sensitive_data_exposure,
        test_broken_access_control,
        test_security_misconfiguration,
        test_known_vulnerabilities,
        test_insufficient_logging,
        test_race_conditions,
        test_buffer_overflow,
        test_format_string,
        test_ldap_injection,
        test_xpath_injection,
        test_nosql_injection,
        test_graphql_injection,
        test_template_injection,
        test_ssti,
        # test_file_upload_vulnerabilities,  # Temporarily disabled
        test_http_parameter_pollution,
        test_host_header_injection,
        test_http_request_smuggling,
        test_insecure_deserialization,
        test_cors_misconfiguration,
        test_clickjacking,
        test_header_validations,
        test_fuzzing,
        test_nmap_integration
    ]

    # Execute tests in parallel for faster scanning
    with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
        future_to_test = {executor.submit(test_func, base_url): test_func for test_func in vulnerability_tests}
        for future in concurrent.futures.as_completed(future_to_test):
            test_func = future_to_test[future]
            try:
                vulnerabilities = future.result()
                all_vulnerabilities.extend(vulnerabilities)
            except Exception as e:
                print(f"Error in {test_func.__name__}: {e}")

    # Add manual replication steps for each vulnerability
    manual_steps = {
        "SQL Injection": "To manually test for SQL injection, send a {method} request to {endpoint} with the payload '{payload}' in the query parameters or POST data (e.g., add ?q={payload} for GET). Look for SQL error messages like 'syntax error' or unexpected database behavior indicating the vulnerability.",
        "Command Injection": "For command injection testing, use a {method} request to {endpoint} and inject the payload '{payload}' into fields like user input or file paths. Check if system commands execute, such as seeing command output or system responses in the reply.",
        "XXE": "To test for XML External Entity (XXE), send a {method} request to {endpoint} with XML data containing the payload '{payload}'. Look for external entity resolution or file disclosure in the response.",
        "SSRF": "For Server-Side Request Forgery (SSRF), submit the payload '{payload}' via a {method} request to {endpoint} in parameters that allow URL input. Monitor for internal network access or unexpected responses from internal services.",
        "CSRF": "To manually verify Cross-Site Request Forgery (CSRF), create an HTML form that submits to {endpoint} without CSRF tokens. Ensure the request uses the {method} method and check if actions execute without user intent.",
        "Broken Authentication": "Test broken authentication by attempting common credentials or bypassing login at {endpoint}. Use {method} requests with payloads like '{payload}' and see if you can access protected resources without proper authentication.",
        "Sensitive Data Exposure": "Check for sensitive data exposure by inspecting {endpoint} responses. Use tools to capture traffic and look for unencrypted sensitive information in the response body or headers.",
        "Broken Access Control": "For broken access control, try accessing restricted endpoints like {endpoint} directly. Use different user roles or modify parameters to see if you can view or modify unauthorized data.",
        "Security Misconfiguration": "Identify misconfigurations by reviewing server headers, error pages, and default configurations at {endpoint}. Look for exposed directories, default credentials, or unnecessary services running.",
        "Known Vulnerabilities": "For known vulnerabilities, check if the application at {endpoint} uses outdated libraries or software versions. Use {method} requests and look for version information in responses or error messages.",
        "Insufficient Logging": "Test insufficient logging by performing actions at {endpoint} and checking server logs. Use {method} requests and see if security events are properly logged and monitored.",
        "Race Conditions": "To test race conditions, send multiple concurrent {method} requests to {endpoint} with payloads like '{payload}'. Observe if the application handles simultaneous requests incorrectly.",
        "Buffer Overflow": "For buffer overflow, input extremely long strings like '{payload}' in {method} requests to {endpoint}. Monitor for crashes, memory corruption, or unexpected behavior.",
        "Format String": "Test format string vulnerabilities by sending format specifiers like '{payload}' in {method} requests to {endpoint}. Look for memory leaks or crashes indicating the issue.",
        "LDAP Injection": "For LDAP injection, inject LDAP syntax like '{payload}' in {method} requests to {endpoint}. Check for LDAP error messages or unauthorized directory access.",
        "XPath Injection": "Use XPath expressions like '{payload}' in {method} requests to {endpoint}. Look for XML parsing errors or data extraction beyond intended scope.",
        "NoSQL Injection": "Test NoSQL injection with operators like '{payload}' in {method} requests to {endpoint}. See if you can manipulate queries to access or modify data incorrectly.",
        "GraphQL Injection": "For GraphQL injection, send malicious queries like '{payload}' via {method} to {endpoint}. Check for query manipulation or data leakage.",
        "Template Injection": "Inject template code like '{payload}' in {method} requests to {endpoint}. Look for template rendering errors or code execution.",
        "SSTI": "Test Server-Side Template Injection by sending template payloads like '{payload}' to {endpoint} via {method}. Monitor for template execution or error messages.",
        "HTTP Parameter Pollution": "Duplicate parameters in {method} requests to {endpoint}, e.g., ?param={payload}&param=safe. See if the application mishandles multiple values.",
        "Host Header Injection": "Modify the Host header in {method} requests to {endpoint} with '{payload}'. Check for cache poisoning or redirection to malicious hosts.",
        "HTTP Request Smuggling": "Send malformed HTTP requests with '{payload}' to {endpoint}. Look for request processing discrepancies between proxies and servers.",
        "Insecure Deserialization": "Provide serialized objects with '{payload}' in {method} requests to {endpoint}. Monitor for deserialization errors or arbitrary code execution.",
        "CORS Misconfiguration": "Test CORS by sending requests from different origins to {endpoint}. Check if sensitive data is exposed or if CORS headers allow unauthorized access.",
        "Clickjacking": "Attempt to embed {endpoint} in an iframe on a malicious page. See if X-Frame-Options headers prevent clickjacking attacks.",
        "Header Validations": "Send {method} requests to {endpoint} with malformed or malicious headers like '{payload}'. Look for improper header handling leading to vulnerabilities.",
        "Fuzzing": "Use fuzzing tools to send random data like '{payload}' to {endpoint} via {method}. Identify crashes, errors, or unexpected behaviors.",
        "Nmap Integration": "Run Nmap scans on the target host and ports. Look for open ports, services, and potential vulnerabilities in the network configuration."
    }

    # Remediation steps for each vulnerability
    remediation_steps = {
        "SQL Injection": "Use prepared statements or parameterized queries. Sanitize all user inputs. Implement input validation and use ORM libraries.",
        "Command Injection": "Avoid executing system commands with user input. Use safe APIs and validate/whitelist allowed commands.",
        "XXE": "Disable external entity processing in XML parsers. Use safer alternatives like JSON or restrict DTDs.",
        "SSRF": "Validate and whitelist URLs. Use allowlists for internal resources. Implement proper input sanitization.",
        "CSRF": "Implement CSRF tokens in forms. Use SameSite cookies and validate origins.",
        "Broken Authentication": "Use strong password policies, multi-factor authentication, and secure session management.",
        "Sensitive Data Exposure": "Encrypt sensitive data at rest and in transit. Avoid storing unnecessary sensitive information.",
        "Broken Access Control": "Implement role-based access control (RBAC). Enforce access checks on every request.",
        "Security Misconfiguration": "Follow security best practices for configuration. Regularly audit and update configurations.",
        "Known Vulnerabilities": "Keep software and libraries up to date. Regularly scan for known vulnerabilities.",
        "Insufficient Logging": "Implement comprehensive logging and monitoring. Log security events and set up alerts.",
        "Race Conditions": "Use atomic operations and proper synchronization mechanisms.",
        "Buffer Overflow": "Use safe string handling functions. Implement bounds checking.",
        "Format String": "Avoid user-controlled format strings. Use fixed format specifiers.",
        "LDAP Injection": "Use parameterized LDAP queries. Sanitize and validate inputs.",
        "XPath Injection": "Use parameterized XPath queries or safe APIs.",
        "NoSQL Injection": "Use parameterized queries or ORM. Validate and sanitize inputs.",
        "GraphQL Injection": "Limit query complexity and depth. Implement proper input validation.",
        "Template Injection": "Avoid user-controlled templates. Use safe template engines.",
        "SSTI": "Sanitize inputs and use safe template rendering.",
        "HTTP Parameter Pollution": "Handle multiple parameters correctly. Validate inputs.",
        "Host Header Injection": "Validate Host headers. Avoid using Host for security decisions.",
        "HTTP Request Smuggling": "Ensure consistent parsing between proxies and servers.",
        "Insecure Deserialization": "Avoid deserializing untrusted data. Use safe deserialization methods.",
        "CORS Misconfiguration": "Set appropriate CORS headers. Restrict origins to trusted domains.",
        "Clickjacking": "Set X-Frame-Options header to prevent framing.",
        "Header Validations": "Validate and sanitize HTTP headers. Implement proper header handling.",
        "Fuzzing": "Implement robust input validation and error handling.",
        "Nmap Integration": "Close unnecessary ports. Use firewalls and network segmentation."
    }

    for i, vuln in enumerate(all_vulnerabilities):
        vuln["id"] = f"{i+1}"
        vuln_type = vuln.get("type", "")
        if vuln_type in manual_steps:
            vuln["manual_replication_steps"] = manual_steps[vuln_type].format(
                method=vuln.get("method", "GET"),
                endpoint=vuln.get("endpoint", ""),
                payload=vuln.get("payload", "")
            )
        else:
            vuln["manual_replication_steps"] = f"To manually replicate this {vuln_type} vulnerability, send a {vuln.get('method', 'GET')} request to {vuln.get('endpoint', '')} with the payload '{vuln.get('payload', '')}' and observe for the evidence: {vuln.get('evidence', '')}."
        vuln["remediation_steps"] = remediation_steps.get(vuln_type, "Consult security best practices and OWASP guidelines for remediation.")

    return all_vulnerabilities
