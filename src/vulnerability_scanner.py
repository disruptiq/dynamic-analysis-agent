"""
Basic vulnerability scanning functions for the Dynamic Analysis Agent.
"""

import requests
from urllib.parse import urljoin

def test_sql_injection(base_url):
    """
    Test for SQL injection vulnerabilities.

    Args:
        base_url (str): Base URL to test

    Returns:
        list: List of detected vulnerabilities
    """
    vulnerabilities = []

    sql_payloads = [
        "' OR '1'='1",
        "' OR 1=1 --",
        "admin' --",
        "' UNION SELECT NULL --",
        "' UNION SELECT username, password FROM users --",
        "'; DROP TABLE users --",
        "' OR ''='",
        "1' ORDER BY 1 --",
        "1' ORDER BY 2 --",
        "' AND 1=0 UNION SELECT database() --",
        "' AND 1=0 UNION SELECT table_name FROM information_schema.tables --"
    ]

    test_endpoints = [
        urljoin(base_url, "/login"),
        urljoin(base_url, "/search"),
        urljoin(base_url, "/api/search"),
        urljoin(base_url, "/user"),
        urljoin(base_url, "/admin")
    ]

    for endpoint in test_endpoints:
        for payload in sql_payloads:
            try:
                # Test in query parameters
                params = {"q": payload, "search": payload, "username": payload, "id": payload}
                response = requests.get(endpoint, params=params, timeout=5)

                # Check for SQL error patterns
                error_patterns = [
                    "sql syntax", "mysql error", "postgresql error", "sqlite error",
                    "ora-", "sqlserver", "syntax error", "unclosed quotation mark",
                    "you have an error in your sql syntax"
                ]

                response_text = response.text.lower()
                if any(pattern in response_text for pattern in error_patterns):
                    vulnerabilities.append({
                        "type": "SQL Injection",
                        "endpoint": endpoint,
                        "payload": payload,
                        "method": "GET",
                        "evidence": "SQL error pattern detected"
                    })

                # Test in POST data for login forms - check for authentication bypass
                if "login" in endpoint:
                    data = {"username": payload, "password": "test", "email": payload}
                    response = requests.post(endpoint, data=data, timeout=5)

                    # Check for SQL errors
                    if any(pattern in response.text.lower() for pattern in error_patterns):
                        vulnerabilities.append({
                            "type": "SQL Injection",
                            "endpoint": endpoint,
                            "payload": payload,
                            "method": "POST",
                            "evidence": "SQL error pattern detected"
                        })
                    # Check for authentication bypass (successful login with injection)
                    elif response.status_code == 200 and ("welcome" in response.text.lower() or "logged in" in response.text.lower()):
                        vulnerabilities.append({
                            "type": "SQL Injection",
                            "endpoint": endpoint,
                            "payload": payload,
                            "method": "POST",
                            "evidence": "Authentication bypass successful"
                        })

            except requests.RequestException:
                continue

    return vulnerabilities

def test_command_injection(base_url):
    """
    Test for command injection vulnerabilities.

    Args:
        base_url (str): Base URL to test

    Returns:
        list: List of detected vulnerabilities
    """
    vulnerabilities = []

    cmd_payloads = [
        "; ls -la",
        "| ls -la",
        "`ls -la`",
        "$(ls -la)",
        "; cat /etc/passwd",
        "| cat /etc/passwd",
        "; whoami",
        "| whoami",
        "; ping -c 1 127.0.0.1",
        "; sleep 5",
        "| sleep 5"
    ]

    test_endpoints = [
        urljoin(base_url, "/exec"),
        urljoin(base_url, "/run"),
        urljoin(base_url, "/cmd"),
        urljoin(base_url, "/system"),
        urljoin(base_url, "/api/exec")
    ]

    for endpoint in test_endpoints:
        for payload in cmd_payloads:
            try:
                params = {"cmd": payload, "command": payload, "exec": payload}
                response = requests.get(endpoint, params=params, timeout=10)

                # Check for command execution indicators
                response_text = response.text.lower()
                command_indicators = [
                    "root", "www-data", "nobody", "daemon",  # Common system users
                    "total ", "drwxr", "lrwxr", "-rw-r",  # File listing patterns
                    "usage: ", "command not found",  # Command help/error patterns
                    "version ", "copyright",  # Version info patterns
                ]

                # Check if any command output indicators are present
                if any(indicator in response_text for indicator in command_indicators):
                    vulnerabilities.append({
                        "type": "Command Injection",
                        "endpoint": endpoint,
                        "payload": payload,
                        "method": "GET",
                        "evidence": "Command execution output detected"
                    })

                # Check for timing attacks (sleep command)
                if response.elapsed.total_seconds() > 4:
                    vulnerabilities.append({
                        "type": "Command Injection",
                        "endpoint": endpoint,
                        "payload": payload,
                        "method": "GET",
                        "evidence": "Timing delay detected"
                    })

                # Additional check: if output contains specific command result patterns
                # Only flag if we see actual command output indicators
                command_output_patterns = [
                    "/bin/", "/usr/", "/etc/", "/home/", "/root/",
                    "uid=", "gid=", "groups=", "shell=",
                    "linux", "gnu", "bash", "sh", "zsh"
                ]

                if len(response_text) > 0 and any(pattern in response_text for pattern in command_output_patterns):
                    # Response contains system command output patterns
                    vulnerabilities.append({
                        "type": "Command Injection",
                        "endpoint": endpoint,
                        "payload": payload,
                        "method": "GET",
                        "evidence": "System command output detected"
                    })

            except requests.RequestException:
                continue

    return vulnerabilities

def test_vulnerabilities(base_url):
    """
    Test for common web vulnerabilities.

    Args:
        base_url (str): Base URL to test

    Returns:
        list: List of all detected vulnerabilities
    """
    all_vulnerabilities = []

    # Test for SQL Injection
    sql_vulns = test_sql_injection(base_url)
    all_vulnerabilities.extend(sql_vulns)

    # Test for Command Injection
    cmd_vulns = test_command_injection(base_url)
    all_vulnerabilities.extend(cmd_vulns)

    # Test for XSS (basic)
    xss_payloads = ["<script>alert('xss')</script>", "<img src=x onerror=alert('xss')>", "<svg onload=alert('xss')>"]
    test_endpoint = urljoin(base_url, "/search")  # Assume a search endpoint

    for payload in xss_payloads:
        try:
            params = {"q": payload, "search": payload}
            response = requests.get(test_endpoint, params=params, timeout=5)
            if payload in response.text:
                all_vulnerabilities.append({
                    "type": "Cross-Site Scripting (XSS)",
                    "endpoint": test_endpoint,
                    "payload": payload,
                    "method": "GET",
                    "evidence": "Payload reflected in response"
                })
        except:
            pass

    # Test for directory traversal
    traversal_payloads = ["../../../etc/passwd", "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts", "../../../../../etc/shadow"]
    test_endpoint = urljoin(base_url, "/file")  # Assume a file serving endpoint

    for payload in traversal_payloads:
        try:
            params = {"path": payload, "file": payload}
            response = requests.get(test_endpoint, params=params, timeout=5)
            if "root:" in response.text or "hosts" in response.text or "shadow:" in response.text:
                all_vulnerabilities.append({
                    "type": "Directory Traversal",
                    "endpoint": test_endpoint,
                    "payload": payload,
                    "method": "GET",
                    "evidence": "Sensitive file content detected"
                })
        except:
            pass

    return all_vulnerabilities
